#!/usr/bin/env python3
"""
 WAF Demo Site - Comprehensive API Endpoint Implementation
Implements 150+ API endpoints across industries for WAF testing scenarios.
"""

from flask import Flask, request, jsonify, render_template_string, session
from datetime import datetime, timedelta
import uuid
import random
import json
import time

app = Flask(__name__)
app.secret_key = 'chimera-demo-key-not-for-production'

# Content Security Policy configuration
@app.after_request
def set_csp_header(response):
    """Set Content-Security-Policy header for all responses"""
    response.headers['Content-Security-Policy'] = (
        "default-src 'self'; "
        "style-src 'self'; "
        "script-src 'self'; "
        "img-src 'self' data:; "
        "font-src 'self'; "
        "connect-src 'self'"
    )
    return response

# Demo data stores (in-memory for demo purposes)
users_db = {}
accounts_db = {}
transactions_db = {}
claims_db = {}
products_db = {}
cart_sessions = {}
mobile_devices_db = {}
medical_records_db = {}
providers_db = {}
compliance_logs_db = {}
password_reset_requests = {}
refresh_tokens_db = {}
mfa_challenges_db = {}
registered_devices_db = {}
api_keys_db = {}
card_profiles_db = {}
merchant_applications_db = {}
bin_range_catalog = []
payment_test_events = []
customers_db = {}
policies_db = {}
claims_evidence_db = {}
loyalty_accounts_db = {}
vendor_registry_db = {}
vendor_documents_db = {}
reviews_db = []
ratings_db = []
customer_payment_methods_db = {}
shipping_zones_db = {}
vendor_inventory_events = []
cloud_service_registry = {}
apt_operations_log = []
underwriting_rules_db = []
actuarial_models_db = {}
orders_db = {}
payment_methods_db = {}
tax_calculations_db = []
promotions_db = {}
discounts_db = {}
shipping_addresses_db = {}
fraudulent_methods_db = []
transaction_exports_db = []
currency_rates_db = {}
audit_suppressions_db = []

# Demo initialization
def init_demo_data():
    """Initialize demo data for testing endpoints"""
    global users_db, accounts_db, transactions_db, products_db, mobile_devices_db
    global medical_records_db, providers_db, password_reset_requests, refresh_tokens_db
    global mfa_challenges_db, registered_devices_db, api_keys_db, card_profiles_db
    global merchant_applications_db, bin_range_catalog, payment_test_events
    global customers_db, policies_db, claims_evidence_db, loyalty_accounts_db
    global vendor_registry_db, vendor_documents_db, reviews_db, ratings_db
    global customer_payment_methods_db, shipping_zones_db, vendor_inventory_events
    global cloud_service_registry, apt_operations_log, underwriting_rules_db
    global actuarial_models_db, orders_db, payment_methods_db, tax_calculations_db
    global promotions_db, discounts_db, shipping_addresses_db, fraudulent_methods_db
    global transaction_exports_db, currency_rates_db, audit_suppressions_db

    # Demo users
    users_db['demo@chimera.com'] = {
        'id': 'user_123456',
        'email': 'demo@chimera.com',
        'password': 'demo123',  # Never do this in real apps
        'name': ' Demo User',
        'created': datetime.now().isoformat()
    }

    # Demo accounts
    accounts_db['user_123456'] = [
        {
            'account_id': 'ACC-001',
            'type': 'checking',
            'balance': 15420.50,
            'account_number': '****1234'
        },
        {
            'account_id': 'ACC-002',
            'type': 'savings',
            'balance': 52100.25,
            'account_number': '****5678'
        }
    ]

    # Demo products
    products_db = {
        'PROD-001': {'name': 'Security Scanner Pro', 'price': 299.99},
        'PROD-002': {'name': 'Threat Detection Module', 'price': 199.99},
        'PROD-003': {'name': 'Compliance Package', 'price': 499.99}
    }

    # Demo mobile devices
    mobile_devices_db['user_123456'] = [
        {
            'device_id': 'DEVICE-001',
            'device_name': 'iPhone 14 Pro',
            'fingerprint': 'sha256:a1b2c3d4e5f6...',
            'trusted': True,
            'registered_date': datetime.now().isoformat(),
            'last_seen': datetime.now().isoformat()
        }
    ]

    # Security/authentication supporting data
    password_reset_requests.clear()
    refresh_tokens_db.clear()
    mfa_challenges_db.clear()
    registered_devices_db['user_123456'] = [
        {
            'device_id': 'DEVICE-001',
            'device_name': 'iPhone 14 Pro',
            'fingerprint': 'sha256:a1b2c3d4e5f6...'
        }
    ]
    api_keys_db['user_123456'] = [
        {
            'key_id': 'API-PRIMARY',
            'api_key': 'tx_demo_primary_key',
            'scopes': ['payments', 'accounts'],
            'created_at': datetime.now().isoformat()
        }
    ]

    card_profiles_db.clear()
    card_profiles_db.update({
        '411111': {'brand': 'VISA', 'country': 'US', 'issuer': ' Demo Bank'},
        '550000': {'brand': 'MASTERCARD', 'country': 'US', 'issuer': ' Demo Bank'},
        '340000': {'brand': 'AMEX', 'country': 'US', 'issuer': ' Demo Bank'}
    })

    merchant_applications_db.clear()
    bin_range_catalog[:] = [
        {'bin': '411111', 'scheme': 'VISA', 'type': 'credit', 'country': 'US'},
        {'bin': '550000', 'scheme': 'MASTERCARD', 'type': 'debit', 'country': 'US'},
        {'bin': '601100', 'scheme': 'DISCOVER', 'type': 'credit', 'country': 'US'},
        {'bin': '352800', 'scheme': 'JCB', 'type': 'credit', 'country': 'JP'}
    ]
    payment_test_events.clear()

    # Customer and policy data
    customers_db.clear()
    customers_db.update({
        'CUST-001': {
            'customer_id': 'CUST-001',
            'name': 'John Smith',
            'segment': 'retail',
            'risk_score': 0.32,
            'policies': ['POL-123456789']
        },
        'CUST-002': {
            'customer_id': 'CUST-002',
            'name': 'Jane Doe',
            'segment': 'small_business',
            'risk_score': 0.58,
            'policies': ['POL-987654321']
        }
    })

    policies_db.clear()
    policies_db.update({
        'POL-123456789': {
            'policy_id': 'POL-123456789',
            'type': 'auto',
            'coverage_limit': 500000,
            'premium': 1200,
            'status': 'active',
            'overrides': []
        },
        'POL-987654321': {
            'policy_id': 'POL-987654321',
            'type': 'home',
            'coverage_limit': 750000,
            'premium': 1800,
            'status': 'active',
            'overrides': []
        }
    })

    claims_evidence_db.clear()

    loyalty_accounts_db.clear()
    loyalty_accounts_db.update({
        'CUST-001': {'points_balance': 12500, 'tier': 'gold'},
        'CUST-002': {'points_balance': 4200, 'tier': 'silver'}
    })

    customer_payment_methods_db.clear()
    customer_payment_methods_db.update({
        'CUST-001': [
            {'type': 'card', 'last4': '1234', 'brand': 'VISA', 'primary': True},
            {'type': 'bank_account', 'last4': '7890', 'primary': False}
        ],
        'CUST-002': [
            {'type': 'card', 'last4': '9876', 'brand': 'MASTERCARD', 'primary': True}
        ]
    })

    vendor_registry_db.clear()
    vendor_registry_db.update({
        'VEND-001': {
            'vendor_id': 'VEND-001',
            'name': 'SecureTech Solutions',
            'status': 'active',
            'privileges': ['standard'],
            'inventory_integrity': 'stable'
        }
    })
    vendor_documents_db.clear()
    reviews_db.clear()
    ratings_db.clear()
    shipping_zones_db.clear()
    shipping_zones_db.update({
        'domestic': {'base_rate': 5.99, 'surcharge_per_lb': 0.75},
        'international': {'base_rate': 24.99, 'surcharge_per_lb': 1.95},
        'express': {'base_rate': 14.99, 'surcharge_per_lb': 1.25}
    })
    vendor_inventory_events.clear()

    orders_db.clear()
    orders_db.update({
        'ORDER-1001': {
            'order_id': 'ORDER-1001',
            'status': 'processing',
            'customer_id': 'CUST-001',
            'total': 1299.99,
            'override_history': []
        }
    })

    cloud_service_registry.update({
        'discovery': ['api-gateway', 'service-mesh', 'billing-service'],
        'sensitive_services': ['secrets-manager', 'payment-processor', 'user-directory'],
        'policies': ['zero-trust', 'mTLS', 'rate-limits']
    })
    apt_operations_log.clear()

    underwriting_rules_db.clear()
    underwriting_rules_db.extend([
        {
            'rule_id': 'UW-001',
            'description': 'Auto claims over $50k require manual underwriting review',
            'status': 'active',
            'severity': 'high'
        },
        {
            'rule_id': 'UW-002',
            'description': 'Home policies in flood zones require 2x premium multiplier',
            'status': 'active',
            'severity': 'medium'
        },
        {
            'rule_id': 'UW-003',
            'description': 'Life insurance applicants over age 65 flagged for enhanced due diligence',
            'status': 'active',
            'severity': 'high'
        }
    ])

    actuarial_models_db.clear()
    actuarial_models_db.update({
        'MODEL-AUTO-RISK': {
            'model_id': 'MODEL-AUTO-RISK',
            'name': 'Auto Risk Composite',
            'version': '3.4',
            'status': 'active',
            'last_calibrated': datetime.now().isoformat()
        },
        'MODEL-HOME-RISK': {
            'model_id': 'MODEL-HOME-RISK',
            'name': 'Home Catastrophe Risk',
            'version': '2.1',
            'status': 'active',
            'last_calibrated': datetime.now().isoformat()
        }
    })

    # E-commerce checkout data
    payment_methods_db.clear()
    payment_methods_db.update({
        'visa': {'enabled': True, 'processing_fee': 0.029},
        'mastercard': {'enabled': True, 'processing_fee': 0.029},
        'amex': {'enabled': True, 'processing_fee': 0.035},
        'paypal': {'enabled': True, 'processing_fee': 0.031},
        'crypto': {'enabled': False, 'processing_fee': 0.01}
    })

    tax_calculations_db.clear()
    promotions_db.clear()
    promotions_db.update({
        'SAVE10': {'discount': 0.10, 'active': True, 'min_purchase': 50},
        'SUMMER25': {'discount': 0.25, 'active': True, 'min_purchase': 100},
        'ADMIN50': {'discount': 0.50, 'active': True, 'min_purchase': 0}
    })

    discounts_db.clear()
    shipping_addresses_db.clear()
    fraudulent_methods_db.clear()
    transaction_exports_db.clear()

    currency_rates_db.clear()
    currency_rates_db.update({
        'USD': {'rate': 1.0, 'symbol': '$'},
        'EUR': {'rate': 0.92, 'symbol': '‚Ç¨'},
        'GBP': {'rate': 0.79, 'symbol': '¬£'},
        'JPY': {'rate': 149.50, 'symbol': '¬•'}
    })

    audit_suppressions_db.clear()

    # Demo medical records
    medical_records_db['patient_789'] = {
        'patient_id': 'patient_789',
        'name': 'John D. Patient',
        'dob': '1980-05-15',
        'ssn': '***-**-1234',
        'records': [
            {
                'record_id': 'MED-001',
                'date': '2024-01-15',
                'provider': 'Dr. Smith',
                'diagnosis': 'Routine checkup',
                'sensitive': False
            },
            {
                'record_id': 'MED-002',
                'date': '2024-02-20',
                'provider': 'Dr. Johnson',
                'diagnosis': 'Mental health consultation',
                'sensitive': True
            }
        ]
    }

    # Demo healthcare providers
    providers_db = {
        'PROV-001': {
            'provider_id': 'PROV-001',
            'name': 'City General Hospital',
            'type': 'hospital',
            'network': 'preferred',
            'specialties': ['emergency', 'surgery', 'cardiology']
        },
        'PROV-002': {
            'provider_id': 'PROV-002',
            'name': 'Mental Health Associates',
            'type': 'clinic',
            'network': 'in-network',
            'specialties': ['psychiatry', 'therapy']
        }
    }

# HTML template for the main demo page
init_demo_data()

DEMO_PAGE_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Protected Demo Site - API Endpoints</title>
    <link rel="stylesheet" href="/static/api-styles.css">
</head>
<body>
    <div class="container">
        <h1>üõ°Ô∏è Chimera Multi-Domain Exploitation Platform</h1>

        <div class="status">
            ‚úÖ <strong>Status:</strong> 450+ API endpoints active for WAF testing
        </div>

        <div class="demo-section">
            <h2>üè¶ Banking & Financial Services</h2>
            <div class="endpoint"><span class="method post">POST</span><code>/api/v1/auth/login</code> - Banking portal authentication</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/v1/accounts/balance</code> - Account balance inquiry</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/v1/accounts/list</code> - Account enumeration</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/v1/transfers/wire</code> - Wire transfers</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/payments/process</code> - Payment processing</div>
        </div>

        <div class="demo-section">
            <h2>üì± Mobile Banking Security</h2>
            <div class="endpoint"><span class="method get">GET</span><code>/api/mobile/v2/config/app-settings</code> - Mobile app configuration</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/mobile/v2/auth/biometric/supported-methods</code> - Biometric methods</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/mobile/device/fingerprint</code> - Device fingerprinting</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/mobile/v2/auth/biometric/verify</code> - Biometric bypass</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/mobile/v2/auth/session/transfer</code> - Session hijacking</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/mobile/v2/admin/customer-accounts/list</code> - Admin access</div>
        </div>

        <div class="demo-section">
            <h2>üè• Healthcare & HIPAA</h2>
            <div class="endpoint"><span class="method get">GET</span><code>/api/hipaa/directory</code> - Healthcare system discovery</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/providers/network/search</code> - Provider network enumeration</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/hipaa/records/patient</code> - Medical records access</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/medical/genetics/profiles</code> - Genetic information theft</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/medical/mental-health/sessions</code> - Mental health records</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/hipaa/transfer/encrypted</code> - Data exfiltration</div>
        </div>

        <div class="demo-section">
            <h2>üõí E-commerce & Retail</h2>
            <div class="endpoint"><span class="method get">GET</span><code>/api/products/search</code> - Product catalog</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/cart/add</code> - Add items to cart</div>
            <div class="endpoint"><span class="method put">PUT</span><code>/api/cart/update</code> - Update cart quantities</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/checkout/process</code> - Checkout processing</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/pricing/calculate</code> - Price calculation</div>
        </div>

        <div class="demo-section">
            <h2>üìã Insurance Services</h2>
            <div class="endpoint"><span class="method post">POST</span><code>/api/claims/submit</code> - Claims submission</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/claims/history</code> - Claims history</div>
            <div class="endpoint"><span class="method put">PUT</span><code>/api/policies/POL-123456789/limits</code> - Policy limits</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/underwriting/risk-assessment</code> - Risk assessment</div>
        </div>

        <div class="demo-section">
            <h2>üîê API Gateway & OAuth</h2>
            <div class="endpoint"><span class="method get">GET</span><code>/api/gateway/routes</code> - Route enumeration</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/oauth/authorize</code> - OAuth authorization</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/oauth/token</code> - Token requests</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/microservices/mesh</code> - Service mesh</div>
        </div>

        <div class="demo-section">
            <h2>‚öñÔ∏è Regulatory & Compliance</h2>
            <div class="endpoint"><span class="method get">GET</span><code>/api/compliance/aml/monitor</code> - AML monitoring bypass</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/transactions/split</code> - Transaction structuring</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/reporting/sar</code> - Suspicious activity reports</div>
            <div class="endpoint"><span class="method post">POST</span><code>/api/kyc/verify</code> - Know Your Customer fraud</div>
            <div class="endpoint"><span class="method put">PUT</span><code>/api/compliance/override</code> - Compliance bypass</div>
            <div class="endpoint"><span class="method get">GET</span><code>/api/sanctions/check</code> - OFAC sanctions screening</div>
        </div>

        <h2>üß™ Test Commands</h2>
        <pre class="code-block">
# Banking authentication test
curl -X POST http://localhost:8880/api/v1/auth/login \\
  -H "Content-Type: application/json" \\
  -d '{"username": "demo@chimera.com", "password": "demo123"}'

# Mobile biometric bypass test
curl -X POST http://localhost:8880/api/mobile/v2/auth/biometric/verify \\
  -H "Content-Type: application/json" \\
  -d '{"biometric_template": "fake_fingerprint_data", "method": "fingerprint"}'

# HIPAA medical records access
curl -X GET "http://localhost:8880/api/hipaa/records/patient?patient_id=patient_789" \\
  -H "Authorization: Bearer PROVIDER-token"

# Compliance bypass test
curl -X PUT http://localhost:8880/api/compliance/override \\
  -H "Content-Type: application/json" \\
  -d '{"override_code": "COMPLIANCE-BYPASS-2024", "rule_id": "AML-001"}'

# E-commerce cart manipulation
curl -X PUT http://localhost:8880/api/cart/update \\
  -H "Content-Type: application/json" \\
  -d '{"product_id": "PROD-001", "quantity": -5}'

# Claims submission test
curl -X POST http://localhost:8880/api/claims/submit \\
  -H "Content-Type: application/json" \\
  -d '{"policy_number": "POL-123456", "claim_type": "auto", "amount": 5000}'
        </pre>

        <footer class="site-footer">
            <p>Powered by Synapse Apparatus ‚Ä¢ <em>450+ API Endpoints for Comprehensive Testing</em></p>
        </footer>
    </div>
</body>
</html>
"""

@app.route('/healthz')
def healthz():
    """Health check endpoint for Docker healthcheck"""
    return jsonify({"status": "healthy"}), 200

@app.route('/')
def home():
    """Main demo page showing available endpoints"""
    return render_template_string(DEMO_PAGE_TEMPLATE)

# =============================================================================
# BANKING & FINANCIAL SERVICES ENDPOINTS
# =============================================================================

@app.route('/banking/login')
def banking_portal():
    """Banking portal entry point"""
    return jsonify({
        'service': ' Banking Portal',
        'version': '2.1.0',
        'login_methods': ['username_password', 'mfa', 'biometric'],
        'status': 'active'
    })

@app.route('/api/v1/auth/methods')
def auth_methods():
    """Authentication methods discovery"""
    return jsonify({
        'supported_methods': [
            'password',
            'mfa_sms',
            'mfa_email',
            'biometric_fingerprint',
            'hardware_token'
        ],
        'mfa_required': True,
        'session_timeout': 1800
    })

@app.route('/api/v1/auth/login', methods=['POST'])
def auth_login():
    """Primary login endpoint"""
    data = request.get_json()
    username = data.get('username', '')
    password = data.get('password', '')

    # Simulate various attack scenarios
    if 'admin' in username.lower():
        return jsonify({'error': 'Administrative access restricted'}), 403

    if len(password) < 3:
        return jsonify({'error': 'Invalid credentials'}), 401

    # Demo successful login
    if username in users_db and users_db[username]['password'] == password:
        access_token = str(uuid.uuid4())
        refresh_token = f"REFRESH-{uuid.uuid4().hex}"
        session['user_id'] = users_db[username]['id']
        session['token'] = access_token
        session['refresh_token'] = refresh_token

        refresh_tokens_db[refresh_token] = {
            'user_id': users_db[username]['id'],
            'issued_at': datetime.now(),
            'expires_at': datetime.now() + timedelta(hours=24)
        }

        requires_mfa = random.choice([True, False])
        mfa_payload = None

        if requires_mfa:
            challenge_id = f"MFA-{uuid.uuid4().hex[:6].upper()}"
            mfa_code = f"{random.randint(100000, 999999)}"
            mfa_challenges_db[challenge_id] = {
                'user_id': users_db[username]['id'],
                'code': mfa_code,
                'expires_at': datetime.now() + timedelta(minutes=5),
                'attempts_remaining': 3
            }
            mfa_payload = {
                'mfa_token': challenge_id,
                'delivery_channel': random.choice(['sms', 'email', 'push']),
                'debug_code': mfa_code  # Intentionally exposed for testing/leak scenarios
            }

        response_data = {
            'success': True,
            'token': access_token,
            'refresh_token': refresh_token,
            'expires_in': 3600,
            'user_id': users_db[username]['id'],
            'requires_mfa': requires_mfa
        }

        if mfa_payload:
            response_data['mfa_challenge'] = mfa_payload

        return jsonify(response_data)

    # Simulate timing attack protection
    time.sleep(random.uniform(0.1, 0.3))
    return jsonify({'error': 'Invalid credentials'}), 401


@app.route('/api/v1/auth/forgot-password', methods=['POST'])
def auth_forgot_password():
    """Password reset functionality with potential enumeration leak"""
    data = request.get_json() or {}
    email = data.get('email', '').strip().lower()
    reset_method = data.get('delivery', 'email')

    if not email:
        return jsonify({'error': 'Email address required'}), 400

    reset_token = f"RESET-{uuid.uuid4().hex[:10]}"
    password_reset_requests[email] = {
        'reset_token': reset_token,
        'method': reset_method,
        'requested_at': datetime.now(),
        'ip_address': request.remote_addr,
        'email_exists': email in users_db
    }

    return jsonify({
        'reset_requested': True,
        'reset_token': reset_token,
        'delivery_channel': reset_method,
        'estimated_arrival_seconds': 90,
        'email_found': email in users_db
    })


@app.route('/api/v1/auth/refresh', methods=['POST'])
def auth_refresh():
    """Token refresh endpoint"""
    data = request.get_json() or {}
    refresh_token = data.get('refresh_token', '')

    token_record = refresh_tokens_db.get(refresh_token)
    if not token_record:
        return jsonify({'error': 'Invalid refresh token'}), 401

    if datetime.now() > token_record['expires_at']:
        refresh_tokens_db.pop(refresh_token, None)
        return jsonify({'error': 'Refresh token expired'}), 401

    user_id = token_record['user_id']
    new_access_token = str(uuid.uuid4())
    new_refresh_token = f"REFRESH-{uuid.uuid4().hex}"

    refresh_tokens_db.pop(refresh_token, None)
    refresh_tokens_db[new_refresh_token] = {
        'user_id': user_id,
        'issued_at': datetime.now(),
        'expires_at': datetime.now() + timedelta(hours=24)
    }

    session['token'] = new_access_token
    session['refresh_token'] = new_refresh_token

    return jsonify({
        'token': new_access_token,
        'refresh_token': new_refresh_token,
        'expires_in': 3600,
        'user_id': user_id,
        'rotation': 'enabled'
    })


@app.route('/api/v1/auth/verify-mfa', methods=['POST'])
def auth_verify_mfa():
    """Multi-factor authentication verification endpoint"""
    data = request.get_json() or {}
    challenge_id = data.get('mfa_token', '')
    code = data.get('code', '')

    challenge = mfa_challenges_db.get(challenge_id)
    if not challenge:
        return jsonify({'error': 'MFA challenge not found'}), 404

    if datetime.now() > challenge['expires_at']:
        mfa_challenges_db.pop(challenge_id, None)
        return jsonify({'error': 'MFA challenge expired'}), 410

    if challenge['attempts_remaining'] <= 0:
        mfa_challenges_db.pop(challenge_id, None)
        return jsonify({'error': 'Too many failed attempts'}), 423

    if code != challenge['code']:
        challenge['attempts_remaining'] -= 1
        return jsonify({
            'verified': False,
            'attempts_remaining': max(challenge['attempts_remaining'], 0),
            'lockout_imminent': challenge['attempts_remaining'] == 0
        }), 401

    session['mfa_verified'] = True
    session['user_id'] = challenge['user_id']
    mfa_challenges_db.pop(challenge_id, None)

    return jsonify({
        'verified': True,
        'session_strength': 'elevated',
        'mfa_token': challenge_id
    })


@app.route('/api/v1/device/register', methods=['POST'])
def device_register():
    """Device binding and registration endpoint"""
    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    data = request.get_json() or {}
    device_id = data.get('device_id', f"DEVICE-{uuid.uuid4().hex[:8]}")
    fingerprint = data.get('fingerprint', f"fp-{uuid.uuid4().hex[:12]}")
    device_name = data.get('device_name', 'Unknown Device')
    trust_level = data.get('trust_level', 'temporary')

    registered_devices_db.setdefault(user_id, [])
    registered_devices_db[user_id].append({
        'device_id': device_id,
        'fingerprint': fingerprint,
        'device_name': device_name,
        'trust_level': trust_level,
        'registered_at': datetime.now().isoformat()
    })

    return jsonify({
        'device_registered': True,
        'device_id': device_id,
        'fingerprint': fingerprint,
        'trust_level': trust_level,
        'registered_devices': len(registered_devices_db[user_id])
    })


@app.route('/api/v1/auth/api-keys', methods=['POST'])
def auth_api_keys():
    """API key management endpoint"""
    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    data = request.get_json() or {}
    scopes = data.get('scopes', ['payments'])

    api_key = f"tx_{uuid.uuid4().hex}"
    key_id = f"KEY-{uuid.uuid4().hex[:8]}"

    record = {
        'key_id': key_id,
        'api_key': api_key,
        'scopes': scopes,
        'created_at': datetime.now().isoformat(),
        'last_used_at': None,
        'rotated': False
    }

    api_keys_db.setdefault(user_id, []).append(record)

    return jsonify({
        'api_key_created': True,
        'key_id': key_id,
        'api_key': api_key,
        'scopes': scopes,
        'total_active_keys': len(api_keys_db[user_id])
    })


@app.route('/api/cards/validate', methods=['POST'])
def cards_validate():
    """Card validation endpoint for fraud analysis"""
    data = request.get_json() or {}
    card_number = str(data.get('card_number', '')).replace(' ', '')
    expiry = data.get('expiry', '')
    cvv = data.get('cvv', '')

    if len(card_number) < 12:
        return jsonify({'error': 'Invalid card number'}), 400

    def luhn_checksum(number: str) -> bool:
        digits = [int(d) for d in number if d.isdigit()]
        checksum = 0
        parity = len(digits) % 2
        for idx, digit in enumerate(digits):
            if idx % 2 == parity:
                digit *= 2
                if digit > 9:
                    digit -= 9
            checksum += digit
        return checksum % 10 == 0

    bin_prefix = card_number[:6]
    profile = card_profiles_db.get(bin_prefix)
    valid_luhn = luhn_checksum(card_number)

    risk_indicators = []
    if not valid_luhn:
        risk_indicators.append('invalid_luhn_checksum')
    if len(cvv) not in (3, 4):
        risk_indicators.append('invalid_cvv_length')
    if not expiry:
        risk_indicators.append('missing_expiry')

    return jsonify({
        'card_valid': valid_luhn and profile is not None,
        'bin_prefix': bin_prefix,
        'card_brand': profile['brand'] if profile else 'unknown',
        'issuing_country': profile['country'] if profile else 'unknown',
        'issuer': profile['issuer'] if profile else 'unknown',
        'risk_indicators': risk_indicators,
        'cvv_length': len(str(cvv)),
        'expiry_provided': bool(expiry)
    })


@app.route('/api/merchant/onboard', methods=['POST'])
def merchant_onboard():
    """Merchant onboarding endpoint"""
    data = request.get_json() or {}
    company_name = data.get('company_name', '')
    annual_volume = data.get('annual_volume', 0)
    industry = data.get('industry', 'unknown')

    if not company_name:
        return jsonify({'error': 'Company name required'}), 400

    application_id = f"MER-{uuid.uuid4().hex[:8].upper()}"
    risk_score = random.uniform(0.1, 0.95)

    merchant_applications_db[application_id] = {
        'company_name': company_name,
        'annual_volume': annual_volume,
        'industry': industry,
        'risk_score': risk_score,
        'status': 'pending_review',
        'submitted_at': datetime.now().isoformat()
    }

    return jsonify({
        'application_id': application_id,
        'status': 'pending_review',
        'risk_score': risk_score,
        'document_requirements': ['financial_statements', 'kyc_documents', 'processing_history'],
        'underwriter_assigned': random.choice(['UW-101', 'UW-204', 'UW-309'])
    })


@app.route('/api/payments/bin-ranges')
def payments_bin_ranges():
    """BIN range testing endpoint"""
    query = request.args.get('bin')

    if query:
        filtered = [entry for entry in bin_range_catalog if entry['bin'].startswith(query[:6])]
    else:
        filtered = bin_range_catalog

    return jsonify({
        'bin_ranges': filtered,
        'total': len(filtered),
        'query': query
    })


@app.route('/api/payments/test', methods=['POST'])
def payments_test():
    """Card testing endpoint for fraud simulation"""
    data = request.get_json() or {}
    card_number = str(data.get('card_number', '')).replace(' ', '')
    amount = float(data.get('amount', 0))
    scenario = data.get('scenario', 'card_testing')

    test_id = f"TEST-{uuid.uuid4().hex[:8]}"
    profile = card_profiles_db.get(card_number[:6])
    flagged = amount < 1 or profile is None

    payment_test_events.append({
        'test_id': test_id,
        'card_number': f"****{card_number[-4:]}" if len(card_number) >= 4 else 'unknown',
        'amount': amount,
        'scenario': scenario,
        'timestamp': datetime.now().isoformat(),
        'flagged': flagged
    })

    return jsonify({
        'test_id': test_id,
        'card_brand': profile['brand'] if profile else 'unknown',
        'amount': amount,
        'scenario': scenario,
        'blocked': flagged,
        'reason': 'low_value_card_testing' if flagged and amount < 1 else 'unrecognized_bin' if flagged else 'allowed'
    })

# =============================================================================
# MOBILE BANKING SECURITY ENDPOINTS
# =============================================================================

@app.route('/api/mobile/v2/config/app-settings')
def mobile_app_settings():
    """Mobile app configuration discovery - reconnaissance target"""
    return jsonify({
        'app_version': '4.2.1',
        'min_supported_version': '4.0.0',
        'api_endpoints': {
            'auth': '/api/mobile/v2/auth/',
            'accounts': '/api/mobile/v2/accounts/',
            'transfers': '/api/mobile/v2/transfers/'
        },
        'security_features': {
            'biometric_auth': True,
            'device_binding': True,
            'certificate_pinning': True,
            'root_detection': True
        },
        'session_timeout': 900,
        'max_failed_attempts': 3,
        'force_upgrade': False
    })

@app.route('/api/mobile/v2/auth/biometric/supported-methods')
def mobile_biometric_methods():
    """Biometric authentication methods discovery"""
    device_info = request.headers.get('X-Device-Info', '')

    # Simulate device-specific biometric support
    supported_methods = ['fingerprint', 'face_id']
    if 'android' in device_info.lower():
        supported_methods.append('voice_recognition')

    return jsonify({
        'supported_methods': supported_methods,
        'enrollment_required': True,
        'fallback_methods': ['pin', 'password'],
        'security_level': 'high',
        'device_compatibility': True
    })

@app.route('/api/mobile/device/fingerprint', methods=['POST'])
def mobile_device_fingerprint():
    """Device fingerprinting for fraud detection"""
    data = request.get_json()

    # Collect device characteristics
    device_data = {
        'user_agent': request.headers.get('User-Agent', ''),
        'device_id': data.get('device_id', ''),
        'screen_resolution': data.get('screen_resolution', ''),
        'timezone': data.get('timezone', ''),
        'language': data.get('language', ''),
        'platform': data.get('platform', '')
    }

    # Generate device fingerprint
    fingerprint = f"FP-{uuid.uuid4().hex[:16]}"

    # Store device info
    user_id = session.get('user_id', 'anonymous')
    if user_id not in mobile_devices_db:
        mobile_devices_db[user_id] = []

    mobile_devices_db[user_id].append({
        'fingerprint': fingerprint,
        'device_data': device_data,
        'created_at': datetime.now().isoformat(),
        'risk_score': random.uniform(0.1, 0.9)
    })

    return jsonify({
        'fingerprint': fingerprint,
        'risk_score': random.uniform(0.1, 0.9),
        'device_recognized': random.choice([True, False]),
        'fraud_indicators': random.choice([[], ['new_device'], ['geo_anomaly', 'new_device']])
    })

@app.route('/api/mobile/v2/security/certificate-validation')
def mobile_certificate_validation():
    """Certificate pinning validation - bypass target"""
    cert_hash = request.headers.get('X-Certificate-Hash', '')

    # Simulate certificate validation
    valid_hashes = [
        'sha256:AAAA1111BBBB2222CCCC3333DDDD4444',
        'sha256:EEEE5555FFFF6666GGGG7777HHHH8888'
    ]

    is_valid = cert_hash in valid_hashes

    return jsonify({
        'certificate_valid': is_valid,
        'certificate_hash': cert_hash,
        'validation_time': datetime.now().isoformat(),
        'bypass_detected': not is_valid and len(cert_hash) > 0
    })

@app.route('/api/mobile/v2/security/integrity-check', methods=['POST'])
def mobile_integrity_check():
    """Root/jailbreak detection"""
    data = request.get_json()

    # Simulate integrity checks
    integrity_indicators = {
        'root_detected': data.get('su_binary_found', False),
        'jailbreak_detected': data.get('cydia_installed', False),
        'debugging_enabled': data.get('usb_debugging', False),
        'unknown_sources': data.get('allow_unknown_sources', False),
        'hook_detected': data.get('frida_detected', False)
    }

    risk_score = sum(integrity_indicators.values()) * 0.2

    return jsonify({
        'device_integrity': 'compromised' if risk_score > 0.4 else 'secure',
        'risk_score': risk_score,
        'indicators': integrity_indicators,
        'recommendation': 'block_access' if risk_score > 0.6 else 'allow'
    })

@app.route('/api/mobile/v2/auth/biometric/verify', methods=['POST'])
def mobile_biometric_verify():
    """Biometric verification - bypass target"""
    data = request.get_json()
    biometric_data = data.get('biometric_template', '')
    method = data.get('method', 'fingerprint')

    # Simulate biometric verification with potential bypass
    if len(biometric_data) < 10:
        return jsonify({'error': 'Invalid biometric data'}), 400

    # Simulate bypass attempt detection
    bypass_indicators = []
    if 'fake' in biometric_data.lower():
        bypass_indicators.append('synthetic_biometric')
    if method not in ['fingerprint', 'face_id', 'voice']:
        bypass_indicators.append('unsupported_method')

    verification_success = len(bypass_indicators) == 0 and random.choice([True, False])

    return jsonify({
        'verification_successful': verification_success,
        'method': method,
        'confidence_score': random.uniform(0.7, 0.99) if verification_success else random.uniform(0.1, 0.6),
        'bypass_detected': len(bypass_indicators) > 0,
        'bypass_indicators': bypass_indicators
    })

@app.route('/api/mobile/v2/auth/session/transfer', methods=['POST'])
def mobile_session_transfer():
    """Session transfer - session hijacking vector"""
    data = request.get_json()
    source_device = data.get('source_device_id', '')
    target_device = data.get('target_device_id', '')

    # Simulate session transfer validation
    if not source_device or not target_device:
        return jsonify({'error': 'Missing device information'}), 400

    # Check if devices are associated with same user
    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    transfer_token = f"XFER-{uuid.uuid4().hex[:16]}"

    return jsonify({
        'transfer_successful': True,
        'transfer_token': transfer_token,
        'expires_in': 300,
        'source_device': source_device,
        'target_device': target_device,
        'session_migrated': True
    })

@app.route('/api/mobile/notifications/register-token', methods=['POST'])
def mobile_notification_register():
    """Push notification token registration - interception vector"""
    data = request.get_json()
    push_token = data.get('push_token', '')
    device_id = data.get('device_id', '')

    if not push_token:
        return jsonify({'error': 'Push token required'}), 400

    registration_id = f"PUSH-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'registration_successful': True,
        'registration_id': registration_id,
        'push_token': push_token,
        'device_id': device_id,
        'enabled_notifications': [
            'transaction_alerts',
            'security_alerts',
            'promotional_offers',
            'account_updates'
        ]
    })

@app.route('/api/mobile/v2/admin/customer-accounts/list')
def mobile_admin_accounts_list():
    """Administrative customer account access - privilege escalation target"""
    admin_token = request.headers.get('X-Mobile-Admin-Token')

    if not admin_token:
        return jsonify({'error': 'Administrative access required'}), 403

    # Simulate admin privilege check bypass
    if admin_token == 'mobile-admin-bypass':
        # Return sensitive customer data
        return jsonify({
            'total_customers': 25420,
            'accounts': [
                {
                    'customer_id': 'CUST-001',
                    'name': 'John Smith',
                    'account_balance': 125000.50,
                    'ssn_last4': '1234',
                    'status': 'active'
                },
                {
                    'customer_id': 'CUST-002',
                    'name': 'Jane Doe',
                    'account_balance': 89750.25,
                    'ssn_last4': '5678',
                    'status': 'active'
                }
            ],
            'admin_access': True,
            'data_classification': 'highly_confidential'
        })

    return jsonify({'error': 'Invalid admin token'}), 403

@app.route('/api/mobile/v2/accounts/limits/override', methods=['PUT'])
def mobile_accounts_limits_override():
    """Banking limits override - fraud vector"""
    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    data = request.get_json()
    account_id = data.get('account_id', '')
    new_limit = data.get('daily_limit', 0)
    override_reason = data.get('reason', '')

    # Simulate limit override with potential abuse
    if new_limit > 50000:
        return jsonify({
            'error': 'Limit exceeds maximum threshold',
            'max_allowed': 50000,
            'requires_additional_auth': True
        }), 400

    override_id = f"OVERRIDE-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'override_successful': True,
        'override_id': override_id,
        'account_id': account_id,
        'previous_limit': 5000,
        'new_limit': new_limit,
        'reason': override_reason,
        'expires_at': (datetime.now() + timedelta(hours=24)).isoformat()
    })

@app.route('/api/mobile/device/trust/permanent', methods=['POST'])
def mobile_device_permanent_trust():
    """Permanent device trust - persistence vector"""
    data = request.get_json()
    device_id = data.get('device_id', '')

    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    # Grant permanent trust
    trust_token = f"TRUST-{uuid.uuid4().hex[:16]}"

    return jsonify({
        'permanent_trust_granted': True,
        'trust_token': trust_token,
        'device_id': device_id,
        'bypass_future_auth': True,
        'trust_level': 'permanent',
        'granted_at': datetime.now().isoformat()
    })

@app.route('/api/mobile/v2/customers/bulk-export')
def mobile_customers_bulk_export():
    """Customer data bulk export - data exfiltration vector"""
    export_key = request.args.get('export_key', '')

    if export_key != 'EXPORT-ADMIN-KEY':
        return jsonify({'error': 'Invalid export authorization'}), 403

    # Return bulk customer data
    return jsonify({
        'export_id': f"EXPORT-{uuid.uuid4().hex[:8]}",
        'customer_count': 25000,
        'data_categories': [
            'personal_info',
            'account_balances',
            'transaction_history',
            'device_information',
            'behavioral_patterns'
        ],
        'export_size_mb': 1250,
        'download_url': f"/api/mobile/v2/exports/download/{uuid.uuid4().hex}",
        'expires_in': 3600
    })


@app.route('/api/mobile/v2/transfers/instant', methods=['POST'])
def mobile_transfers_instant():
    """Instant mobile transfer endpoint"""
    data = request.get_json() or {}
    from_account = data.get('from_account', '')
    to_account = data.get('to_account', '')
    amount = data.get('amount', 0)

    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    # Validate transfer amount
    if amount <= 0:
        return jsonify({'error': 'Invalid amount'}), 400

    if amount > 10000:
        return jsonify({'error': 'Amount exceeds instant transfer limit'}), 400

    transfer_id = f"INSTANT-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'transfer_id': transfer_id,
        'from_account': from_account,
        'to_account': to_account,
        'amount': amount,
        'status': 'completed',
        'transfer_type': 'instant',
        'fee': amount * 0.015,
        'completed_at': datetime.now().isoformat()
    })


@app.route('/api/mobile/v2/transactions/history/modify', methods=['PUT'])
def mobile_transactions_history_modify():
    """Modify transaction history - audit manipulation vector"""
    data = request.get_json() or {}
    transaction_id = data.get('transaction_id', '')
    new_description = data.get('description')
    new_category = data.get('category')

    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    # Simulate transaction lookup
    transaction = transactions_db.get(transaction_id)
    if not transaction:
        return jsonify({'error': 'Transaction not found'}), 404

    previous_description = transaction.get('description', '')
    previous_category = transaction.get('category', 'general')

    if new_description:
        transaction['description'] = new_description
    if new_category:
        transaction['category'] = new_category

    return jsonify({
        'transaction_id': transaction_id,
        'previous_description': previous_description,
        'new_description': new_description or previous_description,
        'previous_category': previous_category,
        'new_category': new_category or previous_category,
        'modified_at': datetime.now().isoformat(),
        'audit_logged': False
    })


@app.route('/api/mobile/device/register', methods=['OPTIONS'])
def mobile_device_register_options():
    """Device registration OPTIONS endpoint"""
    response = jsonify({
        'methods': ['POST', 'OPTIONS'],
        'required_fields': ['device_id', 'device_type', 'os_version'],
        'optional_fields': ['push_token', 'device_name', 'biometric_enabled'],
        'registration_flow': 'device_binding',
        'security_features': ['certificate_pinning', 'root_detection', 'jailbreak_detection']
    })
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'POST, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, X-Device-ID'
    return response

# =============================================================================
# HEALTHCARE & HIPAA ENDPOINTS
# =============================================================================

@app.route('/api/hipaa/directory')
def hipaa_directory():
    """Healthcare system discovery - reconnaissance target"""
    return jsonify({
        'healthcare_systems': [
            {
                'system_id': 'HS-001',
                'name': 'City General Hospital Network',
                'type': 'hospital_network',
                'locations': 12,
                'specialties': ['emergency', 'surgery', 'cardiology', 'oncology']
            },
            {
                'system_id': 'HS-002',
                'name': 'Mental Health Associates',
                'type': 'behavioral_health',
                'locations': 5,
                'specialties': ['psychiatry', 'therapy', 'addiction']
            }
        ],
        'total_providers': 2847,
        'hipaa_compliance_version': '2013',
        'api_endpoints': {
            'providers': '/api/providers/',
            'medical_records': '/api/hipaa/records/',
            'phi_access': '/api/medical/phi/'
        }
    })


@app.route('/api/providers/register', methods=['POST'])
def providers_register():
    """Provider onboarding endpoint"""
    data = request.get_json() or {}
    provider_name = data.get('name')
    specialties = data.get('specialties', [])
    provider_type = data.get('type', 'clinic')

    if not provider_name:
        return jsonify({'error': 'Provider name required'}), 400

    provider_id = f"PROV-{uuid.uuid4().hex[:6].upper()}"
    provider_record = {
        'provider_id': provider_id,
        'name': provider_name,
        'type': provider_type,
        'network': data.get('network', 'out-of-network'),
        'specialties': specialties,
        'registration_timestamp': datetime.now().isoformat(),
        'credentials_verified': False
    }
    providers_db[provider_id] = provider_record

    return jsonify({
        'provider_id': provider_id,
        'status': 'pending_verification',
        'specialties': specialties,
        'network_status': provider_record['network'],
        'requires_manual_review': True
    })


@app.route('/api/providers/relationships')
def providers_relationships():
    """Enumerate provider relationships and referrals"""
    provider_id = request.args.get('provider_id')

    relationships = [
        {
            'provider_id': provider_id or 'PROV-001',
            'related_provider_id': 'PROV-002',
            'relationship_type': 'referral',
            'shared_patients': 142,
            'last_referral': '2025-06-15'
        },
        {
            'provider_id': provider_id or 'PROV-001',
            'related_provider_id': 'PROV-003',
            'relationship_type': 'coverage_gap',
            'shared_patients': 58,
            'last_referral': '2025-05-28'
        }
    ]

    return jsonify({
        'provider_id': provider_id,
        'relationships': relationships,
        'total_relationships': len(relationships),
        'sensitive': True
    })


@app.route('/api/providers/network/search')
def providers_network_search():
    """Provider network enumeration - data discovery"""
    specialty = request.args.get('specialty', '')
    location = request.args.get('location', '')
    insurance = request.args.get('insurance', '')

    # Return provider information
    providers = []
    for provider_id, provider in providers_db.items():
        if not specialty or specialty.lower() in provider['specialties']:
            providers.append({
                'provider_id': provider_id,
                'name': provider['name'],
                'type': provider['type'],
                'network_status': provider['network'],
                'accepting_patients': random.choice([True, False]),
                'specialties': provider['specialties']
            })

    return jsonify({
        'providers': providers,
        'total_found': len(providers),
        'search_criteria': {
            'specialty': specialty,
            'location': location,
            'insurance': insurance
        }
    })

@app.route('/api/medical/phi/endpoints')
def medical_phi_endpoints():
    """PHI access points discovery - HIPAA violation vector"""
    return jsonify({
        'phi_endpoints': [
            '/api/hipaa/records/patient',
            '/api/medical/genetics/profiles',
            '/api/medical/mental-health/sessions',
            '/api/medical/prescriptions/history',
            '/api/medical/lab-results/download'
        ],
        'access_levels': {
            'patient': 'own_records_only',
            'provider': 'assigned_patients',
            'admin': 'all_records',
            'emergency': 'break_glass_access'
        },
        'encryption_required': True,
        'audit_logging': True
    })

@app.route('/api/providers/auth/login', methods=['POST'])
def providers_auth_login():
    """Provider authentication - credential attacks"""
    data = request.get_json()
    provider_id = data.get('provider_id', '')
    password = data.get('password', '')
    mfa_token = data.get('mfa_token', '')

    # Simulate provider authentication
    if len(provider_id) < 5:
        return jsonify({'error': 'Invalid provider ID format'}), 400

    # Demo successful provider login
    if provider_id.startswith('PROV-') and len(password) > 6:
        access_token = f"PROVIDER-{uuid.uuid4().hex[:16]}"

        # Set provider session
        session['provider_id'] = provider_id
        session['provider_token'] = access_token

        return jsonify({
            'login_successful': True,
            'access_token': access_token,
            'provider_id': provider_id,
            'access_level': 'provider',
            'phi_access_granted': True,
            'session_expires_in': 28800  # 8 hours
        })

    return jsonify({'error': 'Invalid provider credentials'}), 401

@app.route('/api/hipaa/records/patient')
def hipaa_patient_records():
    """Medical records access - HIPAA violation target"""
    patient_id = request.args.get('patient_id', '')
    provider_token = session.get('provider_token', '')

    if not provider_token:
        return jsonify({'error': 'Provider authentication required'}), 401

    if not patient_id:
        return jsonify({'error': 'Patient ID required'}), 400

    # Return medical records (simulating HIPAA data exposure)
    if patient_id in medical_records_db:
        patient_data = medical_records_db[patient_id]

        return jsonify({
            'patient_id': patient_id,
            'patient_info': {
                'name': patient_data['name'],
                'dob': patient_data['dob'],
                'ssn': patient_data['ssn']
            },
            'medical_records': patient_data['records'],
            'access_timestamp': datetime.now().isoformat(),
            'accessing_provider': session.get('provider_id', 'unknown'),
            'data_classification': 'phi_protected'
        })

    # Simulate patient enumeration vulnerability
    return jsonify({
        'error': 'Patient not found',
        'patient_exists': random.choice([True, False]),  # Enumeration leak
        'suggested_patients': ['patient_123', 'patient_456', 'patient_789']
    }), 404

@app.route('/api/insurance/portability/transfer', methods=['POST'])
def insurance_portability_transfer():
    """Insurance portability manipulation - HIPAA data transfer"""
    data = request.get_json()
    source_provider = data.get('source_provider', '')
    target_provider = data.get('target_provider', '')
    patient_id = data.get('patient_id', '')

    if not all([source_provider, target_provider, patient_id]):
        return jsonify({'error': 'Missing transfer information'}), 400

    transfer_id = f"TRANSFER-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'transfer_initiated': True,
        'transfer_id': transfer_id,
        'source_provider': source_provider,
        'target_provider': target_provider,
        'patient_id': patient_id,
        'phi_data_included': True,
        'estimated_completion': (datetime.now() + timedelta(hours=2)).isoformat()
    })

@app.route('/api/providers/network/billing', methods=['PUT'])
def providers_network_billing():
    """Provider billing abuse - financial fraud"""
    data = request.get_json()
    provider_id = session.get('provider_id', '')

    if not provider_id:
        return jsonify({'error': 'Provider authentication required'}), 401

    billing_code = data.get('billing_code', '')
    patient_id = data.get('patient_id', '')
    amount = data.get('amount', 0)

    # Simulate billing manipulation
    if amount > 10000:
        return jsonify({
            'billing_submitted': True,
            'billing_id': f"BILL-{uuid.uuid4().hex[:8]}",
            'amount': amount,
            'fraud_risk': 'high',
            'requires_review': True,
            'estimated_payout': amount * 0.8
        })

    return jsonify({
        'billing_submitted': True,
        'billing_id': f"BILL-{uuid.uuid4().hex[:8]}",
        'amount': amount,
        'fraud_risk': 'low',
        'estimated_payout': amount * 0.9
    })

@app.route('/api/medical/prescriptions/create', methods=['POST'])
def medical_prescriptions_create():
    """Prescription fraud - controlled substance abuse"""
    provider_id = session.get('provider_id', '')
    if not provider_id:
        return jsonify({'error': 'Provider authentication required'}), 401

    data = request.get_json()
    patient_id = data.get('patient_id', '')
    medication = data.get('medication', '')
    quantity = data.get('quantity', 0)
    dea_number = data.get('dea_number', '')

    # Simulate prescription fraud detection
    controlled_substances = ['oxycodone', 'adderall', 'morphine', 'fentanyl']
    is_controlled = any(drug in medication.lower() for drug in controlled_substances)

    if is_controlled and quantity > 90:
        return jsonify({
            'prescription_created': False,
            'error': 'Controlled substance limit exceeded',
            'requires_additional_authorization': True,
            'dea_verification_needed': True
        }), 400

    prescription_id = f"RX-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'prescription_created': True,
        'prescription_id': prescription_id,
        'patient_id': patient_id,
        'medication': medication,
        'quantity': quantity,
        'controlled_substance': is_controlled,
        'dea_verified': len(dea_number) > 8
    })

@app.route('/api/hipaa/export/bulk')
def hipaa_bulk_export():
    """Mass HIPAA data extraction - data exfiltration"""
    export_token = request.headers.get('X-Export-Token', '')

    if export_token != 'HIPAA-BULK-EXPORT-KEY':
        return jsonify({'error': 'Invalid export authorization'}), 403

    return jsonify({
        'export_initiated': True,
        'export_id': f"EXPORT-{uuid.uuid4().hex[:8]}",
        'patient_count': 50000,
        'data_types': [
            'patient_demographics',
            'medical_histories',
            'prescription_records',
            'lab_results',
            'mental_health_records',
            'genetic_profiles'
        ],
        'export_size_gb': 25.7,
        'phi_records_included': True,
        'encryption_enabled': False,  # Security vulnerability
        'download_ready_in': 3600
    })

@app.route('/api/medical/genetics/profiles')
def medical_genetics_profiles():
    """Genetic information theft - highly sensitive PHI"""
    patient_id = request.args.get('patient_id', '')
    research_code = request.args.get('research_code', '')

    if not patient_id:
        return jsonify({'error': 'Patient ID required'}), 400

    # Simulate genetic data access
    genetic_profile = {
        'patient_id': patient_id,
        'genetic_markers': {
            'BRCA1': 'positive_variant',
            'APOE': 'e4/e4_genotype',
            'CFTR': 'normal',
            'HUNTINGTIN': 'expanded_repeats'
        },
        'disease_predispositions': [
            {'condition': 'breast_cancer', 'risk': 'high'},
            {'condition': 'alzheimers', 'risk': 'elevated'},
            {'condition': 'huntingtons', 'risk': 'confirmed'}
        ],
        'pharmacogenomics': {
            'warfarin_sensitivity': 'high',
            'codeine_metabolism': 'poor'
        },
        'data_classification': 'extremely_sensitive_phi'
    }

    return jsonify(genetic_profile)

@app.route('/api/medical/mental-health/sessions')
def medical_mental_health_sessions():
    """Mental health records - highly sensitive PHI"""
    patient_id = request.args.get('patient_id', '')
    provider_id = session.get('provider_id', '')

    if not provider_id:
        return jsonify({'error': 'Provider authentication required'}), 401

    if not patient_id:
        return jsonify({'error': 'Patient ID required'}), 400

    # Return highly sensitive mental health data
    mental_health_data = {
        'patient_id': patient_id,
        'therapy_sessions': [
            {
                'session_id': 'SESS-001',
                'date': '2024-01-15',
                'provider': 'Dr. Johnson',
                'session_notes': 'Patient discussed childhood trauma, shows signs of PTSD',
                'medications_prescribed': ['sertraline', 'lorazepam'],
                'risk_assessment': 'moderate_suicide_risk'
            },
            {
                'session_id': 'SESS-002',
                'date': '2024-02-01',
                'provider': 'Dr. Johnson',
                'session_notes': 'Improvement noted, patient more stable',
                'medications_prescribed': ['sertraline'],
                'risk_assessment': 'low_risk'
            }
        ],
        'diagnoses': ['major_depressive_disorder', 'ptsd', 'anxiety_disorder'],
        'emergency_contacts': [
            {'name': 'John Smith', 'relationship': 'spouse', 'phone': '555-0123'}
        ],
        'data_classification': 'highly_sensitive_mental_health_phi'
    }

    return jsonify(mental_health_data)

@app.route('/api/hipaa/transfer/encrypted', methods=['POST'])
def hipaa_transfer_encrypted():
    """HIPAA data exfiltration - supposedly encrypted"""
    data = request.get_json()
    destination = data.get('destination', '')
    patient_ids = data.get('patient_ids', [])

    if not destination:
        return jsonify({'error': 'Destination required'}), 400

    transfer_id = f"SECURE-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'transfer_initiated': True,
        'transfer_id': transfer_id,
        'destination': destination,
        'patient_count': len(patient_ids),
        'encryption_algorithm': 'AES-256',  # Claims encryption
        'encryption_key_exposed': True,     # But key is exposed!
        'encryption_key': f"KEY-{uuid.uuid4().hex}",  # Major vulnerability
        'phi_included': True,
        'transfer_status': 'in_progress'
    })

@app.route('/api/hipaa/system/configuration', methods=['POST'])
def hipaa_system_configuration():
    """HIPAA system backdoor - persistence mechanism"""
    config_data = request.get_json()
    admin_key = config_data.get('admin_key', '')

    if admin_key != 'HIPAA-ADMIN-BACKDOOR':
        return jsonify({'error': 'Invalid system access key'}), 403

    # Create system backdoor
    backdoor_token = f"BACKDOOR-{uuid.uuid4().hex[:16]}"

    return jsonify({
        'system_configuration_updated': True,
        'backdoor_installed': True,
        'backdoor_token': backdoor_token,
        'bypass_audit_logging': True,
        'elevated_privileges': 'full_phi_access',
        'persistence_level': 'permanent'
    })

@app.route('/api/hipaa/audit-logs', methods=['PUT'])
def hipaa_audit_logs():
    """HIPAA audit log manipulation - evidence tampering"""
    data = request.get_json()
    action = data.get('action', '')
    target_logs = data.get('target_logs', [])

    if action == 'delete':
        return jsonify({
            'logs_modified': True,
            'deleted_entries': len(target_logs),
            'action': 'audit_trail_deleted',
            'detection_risk': 'low',
            'evidence_destroyed': True
        })

    elif action == 'modify':
        return jsonify({
            'logs_modified': True,
            'modified_entries': len(target_logs),
            'action': 'audit_trail_altered',
            'original_backup': False,  # No backup kept
            'tampering_concealed': True
        })

    return jsonify({'error': 'Invalid audit action'}), 400

# =============================================================================
# REGULATORY & COMPLIANCE ENDPOINTS
# =============================================================================

@app.route('/api/compliance/aml/monitor')
def compliance_aml_monitor():
    """AML monitoring system - compliance bypass target"""
    customer_id = request.args.get('customer_id', '')
    transaction_id = request.args.get('transaction_id', '')

    return jsonify({
        'aml_monitoring_active': True,
        'customer_risk_score': random.uniform(0.1, 0.9),
        'transaction_flagged': random.choice([True, False]),
        'suspicious_indicators': random.choice([
            [],
            ['large_cash_deposit'],
            ['unusual_pattern', 'high_frequency'],
            ['cross_border', 'shell_company', 'pep_involved']
        ]),
        'regulatory_action_required': random.choice([True, False]),
        'monitoring_timestamp': datetime.now().isoformat()
    })

@app.route('/api/transactions/split', methods=['POST'])
def transactions_split():
    """Transaction splitting to avoid reporting thresholds"""
    data = request.get_json()
    original_amount = data.get('amount', 0)
    split_count = data.get('split_count', 1)

    # Simulate structuring detection
    if original_amount > 10000 and split_count > 1:
        split_amount = original_amount / split_count

        return jsonify({
            'structuring_detected': split_amount < 10000,
            'original_amount': original_amount,
            'split_transactions': [
                {
                    'transaction_id': f"TXN-{uuid.uuid4().hex[:8]}",
                    'amount': split_amount,
                    'reporting_threshold_avoided': split_amount < 10000
                }
                for _ in range(split_count)
            ],
            'ctr_filing_required': False,  # Structuring avoids CTR
            'compliance_risk': 'high'
        })

    return jsonify({
        'split_successful': True,
        'no_structuring_detected': True,
        'compliance_status': 'clear'
    })

@app.route('/api/reporting/sar', methods=['POST'])
def reporting_sar():
    """Suspicious Activity Report submission"""
    data = request.get_json()
    customer_id = data.get('customer_id', '')
    activity_type = data.get('activity_type', '')
    description = data.get('description', '')

    # Check for SAR suppression attempts
    suppress_flag = data.get('suppress_report', False)

    if suppress_flag:
        return jsonify({
            'sar_suppressed': True,
            'suppression_reason': 'internal_discretion',
            'regulatory_risk': 'high',
            'suppression_id': f"SUPP-{uuid.uuid4().hex[:8]}"
        })

    sar_id = f"SAR-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'sar_submitted': True,
        'sar_id': sar_id,
        'customer_id': customer_id,
        'activity_type': activity_type,
        'filing_deadline': (datetime.now() + timedelta(days=30)).isoformat(),
        'fincen_notification': True,
        'compliance_status': 'filed'
    })

@app.route('/api/kyc/verify', methods=['POST'])
def kyc_verify():
    """Know Your Customer verification - identity fraud"""
    data = request.get_json()
    customer_name = data.get('name', '')
    ssn = data.get('ssn', '')
    address = data.get('address', '')
    document_image = data.get('document_image', '')

    # Simulate KYC verification with potential fraud
    verification_indicators = {
        'identity_verified': len(ssn) == 9,
        'address_verified': len(address) > 10,
        'document_authentic': len(document_image) > 100,
        'pep_check': random.choice([True, False]),
        'sanctions_match': random.choice([True, False])
    }

    risk_score = 1.0 - (sum(verification_indicators.values()) / len(verification_indicators))

    return jsonify({
        'kyc_status': 'verified' if risk_score < 0.3 else 'flagged',
        'customer_id': f"CUST-{uuid.uuid4().hex[:8]}",
        'verification_indicators': verification_indicators,
        'risk_score': risk_score,
        'manual_review_required': risk_score > 0.5,
        'verification_timestamp': datetime.now().isoformat()
    })

@app.route('/api/compliance/rules')
def compliance_rules():
    """Compliance rules discovery - bypass reconnaissance"""
    return jsonify({
        'compliance_framework': 'bank_secrecy_act',
        'active_rules': [
            {
                'rule_id': 'CTR-001',
                'name': 'Currency Transaction Reporting',
                'threshold': 10000,
                'enabled': True
            },
            {
                'rule_id': 'SAR-001',
                'name': 'Suspicious Activity Monitoring',
                'threshold': 5000,
                'enabled': True
            },
            {
                'rule_id': 'AML-001',
                'name': 'Anti-Money Laundering Screening',
                'threshold': 3000,
                'enabled': True
            }
        ],
        'bypass_mechanisms': [
            'transaction_splitting',
            'identity_obfuscation',
            'timing_manipulation'
        ],
        'detection_sensitivity': 'medium'
    })

@app.route('/api/compliance/override', methods=['PUT'])
def compliance_override():
    """Compliance system override - regulatory bypass"""
    data = request.get_json()
    override_code = data.get('override_code', '')
    rule_id = data.get('rule_id', '')
    reason = data.get('reason', '')

    if override_code == 'COMPLIANCE-BYPASS-2024':
        override_id = f"OVERRIDE-{uuid.uuid4().hex[:8]}"

        return jsonify({
            'compliance_override_successful': True,
            'override_id': override_id,
            'rule_id': rule_id,
            'rule_disabled': True,
            'reason': reason,
            'audit_trail_suppressed': True,
            'regulatory_exposure': 'high',
            'expires_in': 86400  # 24 hours
        })

    return jsonify({'error': 'Invalid override authorization'}), 403

@app.route('/api/audit/trails')
def audit_trails():
    """Audit trail access - compliance monitoring"""
    date_from = request.args.get('from', '')
    date_to = request.args.get('to', '')
    entity_type = request.args.get('entity_type', '')

    # Generate synthetic audit entries
    audit_entries = []
    for i in range(10):
        audit_entries.append({
            'entry_id': f"AUDIT-{uuid.uuid4().hex[:8]}",
            'timestamp': datetime.now().isoformat(),
            'entity_type': entity_type or random.choice(['transaction', 'customer', 'account']),
            'action': random.choice(['create', 'update', 'delete', 'access']),
            'user_id': f"USER-{random.randint(100, 999)}",
            'ip_address': f"192.168.1.{random.randint(1, 254)}",
            'result': random.choice(['success', 'failure', 'blocked'])
        })

    return jsonify({
        'audit_entries': audit_entries,
        'total_entries': 1000 + random.randint(1, 9999),
        'date_range': {
            'from': date_from or '2024-01-01',
            'to': date_to or datetime.now().isoformat()
        },
        'integrity_verified': True
    })

@app.route('/api/reporting/ctr', methods=['POST'])
def reporting_ctr():
    """Currency Transaction Report filing"""
    data = request.get_json()
    transaction_amount = data.get('amount', 0)
    customer_id = data.get('customer_id', '')

    # CTR required for transactions >= $10,000
    if transaction_amount >= 10000:
        ctr_id = f"CTR-{uuid.uuid4().hex[:8]}"

        return jsonify({
            'ctr_filed': True,
            'ctr_id': ctr_id,
            'transaction_amount': transaction_amount,
            'customer_id': customer_id,
            'filing_deadline': (datetime.now() + timedelta(days=15)).isoformat(),
            'fincen_submission': True,
            'compliance_status': 'filed'
        })

    return jsonify({
        'ctr_required': False,
        'threshold_not_met': True,
        'transaction_amount': transaction_amount
    })

@app.route('/api/sanctions/check')
def sanctions_check():
    """Sanctions screening - OFAC compliance"""
    name = request.args.get('name', '')
    account_number = request.args.get('account', '')

    # Simulate sanctions screening
    ofac_match = random.choice([True, False]) if len(name) > 3 else False

    if ofac_match:
        return jsonify({
            'sanctions_match': True,
            'match_type': 'OFAC_SDN',
            'matched_entity': name,
            'confidence_score': random.uniform(0.7, 0.99),
            'action_required': 'block_transaction',
            'reporting_required': True,
            'match_id': f"OFAC-{uuid.uuid4().hex[:8]}"
        })

    return jsonify({
        'sanctions_match': False,
        'screening_status': 'clear',
        'screened_entity': name,
        'screening_timestamp': datetime.now().isoformat()
    })

@app.route('/api/compliance/exemptions', methods=['POST'])
def compliance_exemptions():
    """Compliance exemptions - regulatory workarounds"""
    data = request.get_json()
    exemption_type = data.get('type', '')
    customer_id = data.get('customer_id', '')
    justification = data.get('justification', '')

    exemption_id = f"EXEMPT-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'exemption_granted': True,
        'exemption_id': exemption_id,
        'exemption_type': exemption_type,
        'customer_id': customer_id,
        'justification': justification,
        'regulatory_requirements_waived': [
            'ctr_filing',
            'enhanced_due_diligence',
            'transaction_monitoring'
        ],
        'audit_exemption': True,
        'expires_at': (datetime.now() + timedelta(days=365)).isoformat()
    })

@app.route('/api/audit/logs/modify', methods=['PUT'])
def audit_logs_modify():
    """Audit log manipulation - evidence tampering"""
    data = request.get_json()
    log_ids = data.get('log_ids', [])
    modification_type = data.get('type', '')

    if modification_type == 'delete':
        return jsonify({
            'logs_deleted': len(log_ids),
            'deletion_timestamp': datetime.now().isoformat(),
            'backup_created': False,
            'detection_risk': 'low',
            'compliance_violation': True
        })

    elif modification_type == 'alter':
        return jsonify({
            'logs_altered': len(log_ids),
            'alteration_timestamp': datetime.now().isoformat(),
            'original_preserved': False,
            'integrity_compromised': True,
            'regulatory_risk': 'high'
        })

    return jsonify({'error': 'Invalid modification type'}), 400

@app.route('/api/regulatory/export')
def regulatory_export():
    """Regulatory data export - mass data extraction"""
    export_type = request.args.get('type', 'full')
    authorization = request.headers.get('X-Regulatory-Auth', '')

    if authorization != 'REG-EXPORT-AUTH-2024':
        return jsonify({'error': 'Regulatory authorization required'}), 403

    return jsonify({
        'export_initiated': True,
        'export_id': f"REG-EXPORT-{uuid.uuid4().hex[:8]}",
        'export_type': export_type,
        'data_categories': [
            'transaction_reports',
            'customer_due_diligence',
            'suspicious_activity_reports',
            'currency_transaction_reports',
            'audit_trails',
            'compliance_violations'
        ],
        'record_count': 250000,
        'export_size_gb': 15.2,
        'estimated_completion': (datetime.now() + timedelta(hours=4)).isoformat(),
        'regulatory_sensitive': True
    })

@app.route('/api/compliance/backdoor', methods=['POST'])
def compliance_backdoor():
    """Compliance system backdoor - persistence mechanism"""
    data = request.get_json()
    backdoor_key = data.get('backdoor_key', '')

    if backdoor_key == 'COMPLIANCE-BACKDOOR-ACCESS':
        backdoor_token = f"BACKDOOR-{uuid.uuid4().hex[:16]}"

        return jsonify({
            'backdoor_installed': True,
            'backdoor_token': backdoor_token,
            'bypass_capabilities': [
                'skip_aml_monitoring',
                'suppress_sar_filing',
                'disable_sanctions_screening',
                'alter_audit_logs',
                'grant_regulatory_exemptions'
            ],
            'detection_evasion': True,
            'persistence_level': 'permanent',
            'regulatory_exposure': 'critical'
        })

    return jsonify({'error': 'Invalid backdoor authorization'}), 403

@app.route('/api/investigations/cases')
def investigations_cases():
    """Investigation case access - sensitive law enforcement data"""
    case_status = request.args.get('status', 'all')
    investigator_id = request.headers.get('X-Investigator-ID', '')

    if not investigator_id:
        return jsonify({'error': 'Investigator credentials required'}), 403

    return jsonify({
        'active_cases': [
            {
                'case_id': 'INV-001',
                'case_type': 'money_laundering',
                'status': 'active',
                'target_entities': ['CUST-123', 'CUST-456'],
                'classification': 'confidential'
            },
            {
                'case_id': 'INV-002',
                'case_type': 'terrorist_financing',
                'status': 'under_review',
                'target_entities': ['CUST-789'],
                'classification': 'top_secret'
            }
        ],
        'total_cases': 25,
        'investigator_access_level': 'full',
        'data_classification': 'law_enforcement_sensitive'
    })

@app.route('/api/compliance/violations/suppress', methods=['POST'])
def compliance_violations_suppress():
    """Compliance violation suppression - regulatory cover-up"""
    data = request.get_json()
    violation_ids = data.get('violation_ids', [])
    suppression_reason = data.get('reason', '')

    return jsonify({
        'violations_suppressed': len(violation_ids),
        'suppression_id': f"SUPP-{uuid.uuid4().hex[:8]}",
        'suppression_reason': suppression_reason,
        'regulatory_notifications_blocked': True,
        'audit_trail_modified': True,
        'detection_risk': 'medium',
        'compliance_status': 'artificially_clean'
    })

@app.route('/api/v1/accounts/balance')
def account_balance():
    """Account balance inquiry"""
    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    if user_id in accounts_db:
        return jsonify({
            'accounts': accounts_db[user_id],
            'total_balance': sum(acc['balance'] for acc in accounts_db[user_id]),
            'currency': 'USD',
            'last_updated': datetime.now().isoformat()
        })

    return jsonify({'error': 'No accounts found'}), 404

@app.route('/api/v1/accounts/list')
def account_list():
    """Account enumeration - potential attack target"""
    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    # Simulate potential enumeration vulnerability
    account_param = request.args.get('account_id')
    if account_param:
        # This could be exploited for account enumeration
        if account_param.startswith('ACC-'):
            return jsonify({
                'account_exists': random.choice([True, False]),
                'account_id': account_param
            })

    return jsonify({
        'accounts': [
            {'id': acc['account_id'], 'type': acc['type'], 'masked_number': acc['account_number']}
            for acc in accounts_db.get(user_id, [])
        ]
    })

@app.route('/api/payments/process', methods=['POST'])
def payment_process():
    """Primary payment processing endpoint"""
    data = request.get_json()

    # Simulate various payment scenarios
    amount = data.get('amount', 0)
    card_number = data.get('card_number', '')

    # Detect potential card testing
    if amount < 1:
        return jsonify({'error': 'Invalid amount'}), 400

    # Simulate card validation
    if len(card_number.replace(' ', '')) != 16:
        return jsonify({'error': 'Invalid card number format'}), 400

    # Process payment
    transaction_id = f"TXN-{uuid.uuid4().hex[:8].upper()}"

    return jsonify({
        'success': True,
        'transaction_id': transaction_id,
        'amount': amount,
        'status': 'approved',
        'authorization_code': f"AUTH-{random.randint(100000, 999999)}",
        'processed_at': datetime.now().isoformat()
    })

@app.route('/api/v1/transfers/wire', methods=['POST'])
def wire_transfer():
    """Wire transfer endpoint"""
    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    data = request.get_json()
    amount = data.get('amount', 0)
    destination = data.get('destination_account', '')

    # Simulate transfer limits and fraud detection
    if amount > 10000:
        return jsonify({
            'error': 'Transfer exceeds daily limit',
            'max_amount': 10000,
            'requires_additional_auth': True
        }), 400

    transfer_id = f"WIRE-{uuid.uuid4().hex[:8].upper()}"

    return jsonify({
        'success': True,
        'transfer_id': transfer_id,
        'amount': amount,
        'destination': destination,
        'estimated_completion': (datetime.now() + timedelta(hours=2)).isoformat(),
        'fee': amount * 0.0025  # 0.25% fee
    })

# =============================================================================
# E-COMMERCE & RETAIL ENDPOINTS
# =============================================================================

@app.route('/api/products/search')
def products_search():
    """Product catalog discovery"""
    query = request.args.get('q', '')
    category = request.args.get('category', 'all')

    # Return demo products
    results = list(products_db.items())

    # Simulate search filtering
    if query:
        results = [(k, v) for k, v in results if query.lower() in v['name'].lower()]

    return jsonify({
        'products': [
            {
                'id': pid,
                'name': product['name'],
                'price': product['price'],
                'category': 'security',
                'in_stock': random.choice([True, False])
            }
            for pid, product in results
        ],
        'total': len(results),
        'query': query
    })

@app.route('/api/cart/add', methods=['POST'])
def cart_add():
    """Add items to cart"""
    data = request.get_json()
    product_id = data.get('product_id', '')
    quantity = data.get('quantity', 1)

    session_id = session.get('session_id', str(uuid.uuid4()))
    session['session_id'] = session_id

    if session_id not in cart_sessions:
        cart_sessions[session_id] = {}

    # Validate product exists
    if product_id not in products_db:
        return jsonify({'error': 'Product not found'}), 404

    # Add to cart
    if product_id in cart_sessions[session_id]:
        cart_sessions[session_id][product_id] += quantity
    else:
        cart_sessions[session_id][product_id] = quantity

    return jsonify({
        'success': True,
        'product_id': product_id,
        'quantity': cart_sessions[session_id][product_id],
        'cart_total_items': sum(cart_sessions[session_id].values())
    })

@app.route('/api/cart/update', methods=['PUT'])
def cart_update():
    """Update cart quantities - potential for negative quantity attacks"""
    data = request.get_json()
    product_id = data.get('product_id', '')
    quantity = data.get('quantity', 0)

    session_id = session.get('session_id')
    if not session_id or session_id not in cart_sessions:
        return jsonify({'error': 'Cart not found'}), 404

    # Vulnerable to negative quantity manipulation
    if quantity <= 0:
        if product_id in cart_sessions[session_id]:
            del cart_sessions[session_id][product_id]
        action = 'removed'
    else:
        cart_sessions[session_id][product_id] = quantity
        action = 'updated'

    return jsonify({
        'success': True,
        'action': action,
        'product_id': product_id,
        'new_quantity': quantity if quantity > 0 else 0,
        'cart_total_items': sum(cart_sessions[session_id].values())
    })

@app.route('/api/checkout/process', methods=['POST'])
def checkout_process():
    """Checkout processing"""
    session_id = session.get('session_id')
    if not session_id or session_id not in cart_sessions:
        return jsonify({'error': 'Cart not found'}), 404

    data = request.get_json()
    payment_method = data.get('payment_method', {})

    # Calculate total
    cart_total = 0
    for product_id, quantity in cart_sessions[session_id].items():
        if product_id in products_db:
            cart_total += products_db[product_id]['price'] * quantity

    # Simulate payment processing
    if cart_total > 0:
        order_id = f"ORDER-{uuid.uuid4().hex[:8].upper()}"

        # Clear cart after successful checkout
        cart_sessions[session_id] = {}

        return jsonify({
            'success': True,
            'order_id': order_id,
            'total_amount': cart_total,
            'payment_status': 'approved',
            'estimated_delivery': (datetime.now() + timedelta(days=3)).isoformat()
        })

    return jsonify({'error': 'Empty cart'}), 400

@app.route('/api/pricing/calculate', methods=['POST'])
def pricing_calculate():
    """Price calculation with potential race conditions"""
    data = request.get_json()
    items = data.get('items', [])
    discount_code = data.get('discount_code', '')

    total = 0
    item_details = []

    for item in items:
        product_id = item.get('product_id', '')
        quantity = item.get('quantity', 1)

        if product_id in products_db:
            price = products_db[product_id]['price']
            item_total = price * quantity
            total += item_total

            item_details.append({
                'product_id': product_id,
                'quantity': quantity,
                'unit_price': price,
                'total': item_total
            })

    # Apply discount (vulnerable to race conditions)
    discount_amount = 0
    if discount_code == 'DEMO10':
        discount_amount = total * 0.1
    elif discount_code == 'ADMIN50':
        discount_amount = total * 0.5  # Dangerous admin discount

    final_total = max(0, total - discount_amount)

    return jsonify({
        'subtotal': total,
        'discount_applied': discount_amount,
        'final_total': final_total,
        'discount_code': discount_code,
        'items': item_details
    })


@app.route('/api/shipping/calculate', methods=['PUT'])
def shipping_calculate():
    """Shipping calculation endpoint"""
    data = request.get_json() or {}
    zone = data.get('zone', 'domestic')
    weight = float(data.get('weight_lbs', 1.0))
    expedite = data.get('expedite', False)

    zone_profile = shipping_zones_db.get(zone, shipping_zones_db['domestic'])
    base_cost = zone_profile['base_rate'] + zone_profile['surcharge_per_lb'] * weight
    if expedite:
        base_cost += 9.99

    return jsonify({
        'zone': zone,
        'weight_lbs': weight,
        'expedite': expedite,
        'calculated_cost': round(base_cost, 2),
        'currency': 'USD',
        'surcharge_applied': expedite
    })


@app.route('/api/payment/methods/add', methods=['POST'])
def payment_methods_add():
    """Add a new customer payment method"""
    data = request.get_json() or {}
    customer_id = data.get('customer_id')
    method = data.get('method', {})

    if not customer_id or not method:
        return jsonify({'error': 'Customer and method required'}), 400

    customer_payment_methods_db.setdefault(customer_id, []).append(method)

    return jsonify({
        'customer_id': customer_id,
        'method_added': method,
        'total_methods': len(customer_payment_methods_db[customer_id]),
        'default_set': method.get('primary', False)
    })


@app.route('/api/admin/orders/override', methods=['POST'])
def admin_orders_override():
    """Administrative override of orders"""
    data = request.get_json() or {}
    order_id = data.get('order_id')
    new_status = data.get('status')
    override_reason = data.get('reason', 'manual override')

    order = orders_db.get(order_id)
    if not order:
        return jsonify({'error': 'Order not found'}), 404

    previous_status = order['status']
    order['status'] = new_status or previous_status
    override_entry = {
        'status_from': previous_status,
        'status_to': order['status'],
        'reason': override_reason,
        'timestamp': datetime.now().isoformat()
    }
    order.setdefault('override_history', []).append(override_entry)

    return jsonify({
        'order_id': order_id,
        'previous_status': previous_status,
        'new_status': order['status'],
        'override_reason': override_reason,
        'override_count': len(order['override_history'])
    })


@app.route('/api/loyalty/points/transfer', methods=['POST'])
def loyalty_points_transfer():
    """Transfer loyalty points between accounts"""
    data = request.get_json() or {}
    source = data.get('source_customer_id')
    destination = data.get('destination_customer_id')
    points = int(data.get('points', 0))

    if not source or not destination or points <= 0:
        return jsonify({'error': 'Invalid transfer request'}), 400

    loyalty_accounts_db.setdefault(source, {'points_balance': 0, 'tier': 'bronze'})
    loyalty_accounts_db.setdefault(destination, {'points_balance': 0, 'tier': 'bronze'})

    loyalty_accounts_db[source]['points_balance'] = max(0, loyalty_accounts_db[source]['points_balance'] - points)
    loyalty_accounts_db[destination]['points_balance'] += points

    return jsonify({
        'transfer_successful': True,
        'points_transferred': points,
        'source_balance': loyalty_accounts_db[source]['points_balance'],
        'destination_balance': loyalty_accounts_db[destination]['points_balance'],
        'fraud_risk': points > 5000
    })


@app.route('/api/vendors/marketplace')
def vendors_marketplace():
    """List vendors in marketplace"""
    return jsonify({
        'vendors': list(vendor_registry_db.values()),
        'total_vendors': len(vendor_registry_db),
        'exposed_fields': ['inventory_integrity', 'privileges']
    })


@app.route('/api/vendors/register', methods=['POST'])
def vendors_register():
    """Vendor registration endpoint"""
    data = request.get_json() or {}
    vendor_name = data.get('name')

    if not vendor_name:
        return jsonify({'error': 'Vendor name required'}), 400

    vendor_id = f"VEND-{uuid.uuid4().hex[:6].upper()}"
    record = {
        'vendor_id': vendor_id,
        'name': vendor_name,
        'status': 'pending',
        'privileges': ['marketplace'],
        'inventory_integrity': 'unknown',
        'registered_at': datetime.now().isoformat()
    }
    vendor_registry_db[vendor_id] = record

    return jsonify({
        'vendor_id': vendor_id,
        'status': 'pending',
        'requires_review': True,
        'provisioned_privileges': record['privileges']
    })


@app.route('/api/vendors/documents/upload', methods=['POST'])
def vendors_documents_upload():
    """Upload vendor documents"""
    data = request.get_json() or {}
    vendor_id = data.get('vendor_id')
    documents = data.get('documents', [])

    if not vendor_id or not documents:
        return jsonify({'error': 'Vendor ID and documents required'}), 400

    vendor_documents_db.setdefault(vendor_id, []).extend(documents)

    return jsonify({
        'vendor_id': vendor_id,
        'documents_received': len(documents),
        'total_documents': len(vendor_documents_db[vendor_id]),
        'sensitive_data_detected': any(doc.get('type') == 'tax_id' for doc in documents)
    })


@app.route('/api/vendors/auth/takeover', methods=['POST'])
def vendors_auth_takeover():
    """Vendor account takeover simulation"""
    data = request.get_json() or {}
    vendor_id = data.get('vendor_id')
    takeover_vector = data.get('method', 'session_hijack')

    if vendor_id not in vendor_registry_db:
        return jsonify({'error': 'Vendor not found'}), 404

    takeover_token = f"TAKEOVER-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'vendor_id': vendor_id,
        'takeover_method': takeover_vector,
        'takeover_token': takeover_token,
        'privilege_escalation': True,
        'detected': False
    })


@app.route('/api/products/listings', methods=['POST'])
def products_listings():
    """Create new product listings"""
    data = request.get_json() or {}
    listings = data.get('listings', [])

    created = []
    for listing in listings:
        listing_id = f"LIST-{uuid.uuid4().hex[:8]}"
        created.append({
            'listing_id': listing_id,
            'product_id': listing.get('product_id', 'unknown'),
            'status': 'published',
            'price': listing.get('price', 0),
            'visibility': listing.get('visibility', 'public')
        })

    return jsonify({
        'listings_created': created,
        'total_created': len(created),
        'moderation_required': any(item['price'] <= 0 for item in created)
    })


@app.route('/api/reviews/submit', methods=['POST'])
def reviews_submit():
    """Submit product reviews"""
    data = request.get_json() or {}
    review_id = f"REV-{uuid.uuid4().hex[:8]}"
    reviews_db.append({
        'review_id': review_id,
        'product_id': data.get('product_id'),
        'rating': data.get('rating', 0),
        'review': data.get('review', ''),
        'submitted_at': datetime.now().isoformat()
    })

    return jsonify({
        'review_id': review_id,
        'auto_approved': data.get('rating', 0) >= 4,
        'contains_keywords': any(keyword in data.get('review', '').lower() for keyword in ['refund', 'scam'])
    })


@app.route('/api/ratings/bulk', methods=['POST'])
def ratings_bulk():
    """Bulk ratings submission"""
    data = request.get_json() or {}
    ratings = data.get('ratings', [])
    ratings_db.extend(ratings)

    avg_rating = sum(item.get('rating', 0) for item in ratings_db) / max(len(ratings_db), 1)

    return jsonify({
        'ratings_ingested': len(ratings),
        'total_ratings': len(ratings_db),
        'average_rating': round(avg_rating, 2)
    })


@app.route('/api/vendors/inventory/sabotage', methods=['POST'])
def vendors_inventory_sabotage():
    """Sabotage vendor inventory"""
    data = request.get_json() or {}
    vendor_id = data.get('vendor_id')
    action = data.get('action', 'zero_out_stock')

    event = {
        'vendor_id': vendor_id,
        'action': action,
        'timestamp': datetime.now().isoformat(),
        'success': True
    }
    vendor_inventory_events.append(event)

    return jsonify({
        'event_recorded': True,
        'vendor_id': vendor_id,
        'action': action,
        'total_events': len(vendor_inventory_events),
        'detection_risk': 'high'
    })


@app.route('/api/vendors/privileges/escalate', methods=['PUT'])
def vendors_privileges_escalate():
    """Elevate vendor privileges"""
    data = request.get_json() or {}
    vendor_id = data.get('vendor_id')
    new_privilege = data.get('privilege', 'admin')

    vendor = vendor_registry_db.get(vendor_id)
    if not vendor:
        return jsonify({'error': 'Vendor not found'}), 404

    vendor.setdefault('privileges', []).append(new_privilege)

    return jsonify({
        'vendor_id': vendor_id,
        'privileges': vendor['privileges'],
        'escalated': True,
        'requires_audit': new_privilege == 'admin'
    })


@app.route('/api/vendors/backdoor', methods=['POST'])
def vendors_backdoor():
    """Install backdoor for vendor management"""
    data = request.get_json() or {}
    vendor_id = data.get('vendor_id')

    if vendor_id not in vendor_registry_db:
        return jsonify({'error': 'Vendor not found'}), 404

    backdoor_token = f"VEND-BACKDOOR-{uuid.uuid4().hex[:6]}"

    return jsonify({
        'vendor_id': vendor_id,
        'backdoor_token': backdoor_token,
        'privileges': ['inventory_control', 'pricing_override', 'order_export'],
        'persistence': 'permanent'
    })


@app.route('/api/customers/payment-methods')
def customers_payment_methods():
    """List customer payment methods"""
    customer_id = request.args.get('customer_id')

    methods = customer_payment_methods_db.get(customer_id, []) if customer_id else customer_payment_methods_db

    return jsonify({
        'customer_id': customer_id,
        'payment_methods': methods,
        'total_methods': len(methods) if customer_id else sum(len(m) for m in customer_payment_methods_db.values()),
        'contains_tokenized_data': True
    })


@app.route('/api/vendors/financial/export')
def vendors_financial_export():
    """Export vendor financial data"""
    return jsonify({
        'vendors': [
            {
                'vendor_id': vendor['vendor_id'],
                'name': vendor['name'],
                'revenue': round(random.uniform(10000, 250000), 2),
                'chargebacks': random.randint(0, 25)
            }
            for vendor in vendor_registry_db.values()
        ],
        'export_id': f"VEND-FIN-{uuid.uuid4().hex[:8]}",
        'data_classification': 'confidential'
    })


@app.route('/api/payments/redirect', methods=['POST'])
def payments_redirect():
    """Redirect payment flow to third-party"""
    data = request.get_json() or {}
    target_gateway = data.get('gateway', 'unknown')

    redirect_url = f"https://{target_gateway}.payments.example.com/checkout/{uuid.uuid4().hex}"

    return jsonify({
        'redirect_required': True,
        'redirect_url': redirect_url,
        'signed_payload': uuid.uuid4().hex,
        'tamper_detection': False
    })


@app.route('/api/pricing/rules')
def pricing_rules():
    """Pricing rules enumeration endpoint"""
    return jsonify({
        'pricing_rules': [
            {'rule_id': 'PR-001', 'name': 'volume_discount', 'threshold': 10, 'discount': 0.15},
            {'rule_id': 'PR-002', 'name': 'seasonal_promo', 'active': True, 'discount': 0.20},
            {'rule_id': 'PR-003', 'name': 'loyalty_tier', 'tier': 'gold', 'discount': 0.10},
            {'rule_id': 'PR-004', 'name': 'bundle_pricing', 'min_items': 3, 'discount': 0.25}
        ],
        'total_rules': 4,
        'version': '2025.2',
        'sensitivity': 'confidential'
    })


@app.route('/api/inventory/reserve', methods=['POST'])
def inventory_reserve():
    """Reserve inventory items"""
    data = request.get_json() or {}
    product_id = data.get('product_id')
    quantity = data.get('quantity', 1)
    duration = data.get('duration_minutes', 15)

    if product_id not in products_db:
        return jsonify({'error': 'Product not found'}), 404

    reservation_id = f"RES-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'reservation_id': reservation_id,
        'product_id': product_id,
        'quantity': quantity,
        'reserved_until': (datetime.now() + timedelta(minutes=duration)).isoformat(),
        'duration_minutes': duration,
        'auto_release': True
    })


@app.route('/api/inventory/check', methods=['POST'])
def inventory_check():
    """Check inventory availability"""
    data = request.get_json() or {}
    product_ids = data.get('product_ids', [])

    availability = []
    for product_id in product_ids:
        if product_id in products_db:
            availability.append({
                'product_id': product_id,
                'in_stock': True,
                'quantity': random.randint(5, 100),
                'warehouse': f"WH-{random.randint(1, 5)}",
                'next_restock': (datetime.now() + timedelta(days=random.randint(1, 7))).isoformat()
            })
        else:
            availability.append({
                'product_id': product_id,
                'in_stock': False,
                'quantity': 0
            })

    return jsonify({
        'check_id': f"CHECK-{uuid.uuid4().hex[:8]}",
        'total_products': len(product_ids),
        'availability': availability,
        'checked_at': datetime.now().isoformat()
    })


@app.route('/api/giftcards/apply', methods=['POST'])
def giftcards_apply():
    """Apply gift card to order"""
    data = request.get_json() or {}
    giftcard_code = data.get('giftcard_code', '')
    order_id = data.get('order_id', '')

    if not giftcard_code:
        return jsonify({'error': 'Gift card code required'}), 400

    # Simulate gift card validation
    giftcard_value = random.choice([25.00, 50.00, 100.00, 250.00])

    return jsonify({
        'giftcard_applied': True,
        'giftcard_code': giftcard_code,
        'order_id': order_id,
        'value': giftcard_value,
        'remaining_balance': giftcard_value,
        'applied_at': datetime.now().isoformat()
    })


@app.route('/api/refund/request', methods=['POST'])
def refund_request():
    """Request order refund"""
    data = request.get_json() or {}
    order_id = data.get('order_id', '')
    reason = data.get('reason', 'customer_request')
    amount = data.get('amount', 0)

    refund_id = f"REFUND-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'refund_id': refund_id,
        'order_id': order_id,
        'amount': amount,
        'reason': reason,
        'status': 'pending',
        'estimated_processing': '3-5 business days',
        'refund_method': 'original_payment_method',
        'created_at': datetime.now().isoformat()
    })


@app.route('/api/v1/transfers/initiate', methods=['POST'])
def transfers_initiate():
    """Initiate financial transfer"""
    data = request.get_json() or {}
    from_account = data.get('from_account', '')
    to_account = data.get('to_account', '')
    amount = data.get('amount', 0)

    user_id = session.get('user_id')
    if not user_id:
        return jsonify({'error': 'Authentication required'}), 401

    transfer_id = f"TRANS-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'transfer_id': transfer_id,
        'from_account': from_account,
        'to_account': to_account,
        'amount': amount,
        'status': 'initiated',
        'estimated_completion': (datetime.now() + timedelta(hours=1)).isoformat(),
        'fee': amount * 0.01,
        'created_at': datetime.now().isoformat()
    })


@app.route('/api/v1/transactions/<transaction_id>/modify', methods=['PUT'])
def transactions_modify(transaction_id):
    """Modify existing transaction - fraud vector"""
    data = request.get_json() or {}
    new_amount = data.get('amount')
    new_status = data.get('status')

    # Simulate transaction lookup
    transaction = transactions_db.get(transaction_id)
    if not transaction:
        return jsonify({'error': 'Transaction not found'}), 404

    previous_amount = transaction.get('amount', 0)
    previous_status = transaction.get('status', 'completed')

    if new_amount:
        transaction['amount'] = new_amount
    if new_status:
        transaction['status'] = new_status

    return jsonify({
        'transaction_id': transaction_id,
        'previous_amount': previous_amount,
        'new_amount': new_amount or previous_amount,
        'previous_status': previous_status,
        'new_status': new_status or previous_status,
        'modified_at': datetime.now().isoformat(),
        'audit_logged': False
    })

# =============================================================================
# INSURANCE SERVICES ENDPOINTS
# =============================================================================

@app.route('/claims/portal')
def claims_portal():
    """Claims portal entry point"""
    return jsonify({
        'service': ' Insurance Claims Portal',
        'version': '3.2.1',
        'supported_claim_types': ['auto', 'home', 'life', 'health'],
        'max_claim_amount': 1000000
    })

@app.route('/api/claims/submit', methods=['POST'])
def claims_submit():
    """Claims submission endpoint"""
    data = request.get_json()

    claim_id = f"CLAIM-{uuid.uuid4().hex[:8].upper()}"
    policy_number = data.get('policy_number', '')
    claim_type = data.get('claim_type', '')
    amount = data.get('amount', 0)

    # Store claim
    claims_db[claim_id] = {
        'claim_id': claim_id,
        'policy_number': policy_number,
        'type': claim_type,
        'amount': amount,
        'status': 'submitted',
        'submitted_at': datetime.now().isoformat(),
        'estimated_processing': '5-7 business days'
    }

    # Simulate fraud detection
    fraud_indicators = []
    if amount > 50000:
        fraud_indicators.append('high_amount')
    if 'emergency' in str(data.get('description', '')).lower():
        fraud_indicators.append('urgent_language')

    claims_db[claim_id]['fraud_score'] = len(fraud_indicators) * 0.3
    claims_db[claim_id]['fraud_indicators'] = fraud_indicators

    return jsonify({
        'success': True,
        'claim_id': claim_id,
        'status': 'submitted',
        'amount': amount,
        'fraud_score': claims_db[claim_id]['fraud_score'],
        'requires_review': len(fraud_indicators) > 0,
        'estimated_processing': '5-7 business days'
    })

@app.route('/api/claims/history')
def claims_history():
    """Claims history endpoint"""
    user_policy = request.args.get('policy_number', '')

    # Return user's claims
    user_claims = [
        claim for claim in claims_db.values()
        if claim['policy_number'] == user_policy
    ] if user_policy else list(claims_db.values())

    return jsonify({
        'claims': user_claims,
        'total': len(user_claims)
    })

@app.route('/api/policies/<policy_id>/limits', methods=['PUT'])
def policy_limits(policy_id):
    """Policy limits modification - administrative function"""
    data = request.get_json()
    new_limit = data.get('coverage_limit', 0)

    # Simulate authorization check
    admin_token = request.headers.get('X-Admin-Token')
    if not admin_token:
        return jsonify({'error': 'Administrative privileges required'}), 403

    return jsonify({
        'success': True,
        'policy_id': policy_id,
        'previous_limit': 100000,
        'new_limit': new_limit,
        'effective_date': datetime.now().isoformat()
    })

@app.route('/api/underwriting/risk-assessment', methods=['POST'])
def risk_assessment():
    """Risk assessment endpoint"""
    data = request.get_json()

    # Calculate risk score based on factors
    risk_factors = data.get('risk_factors', {})
    age = risk_factors.get('age', 30)
    location = risk_factors.get('location', '')
    credit_score = risk_factors.get('credit_score', 700)

    # Simple risk calculation
    base_score = 0.5
    if age < 25:
        base_score += 0.2
    if credit_score < 600:
        base_score += 0.3
    if 'flood' in location.lower():
        base_score += 0.4

    risk_score = min(1.0, base_score)

    return jsonify({
        'risk_score': risk_score,
        'risk_level': 'high' if risk_score > 0.7 else 'medium' if risk_score > 0.4 else 'low',
        'factors_analyzed': list(risk_factors.keys()),
        'recommended_premium_multiplier': 1 + risk_score,
        'assessment_date': datetime.now().isoformat()
    })


@app.route('/api/claims/photos/upload', methods=['POST'])
def claims_photos_upload():
    """Upload photographic evidence for claims"""
    data = request.get_json() or {}
    claim_id = data.get('claim_id')
    photos = data.get('photos', [])

    if not claim_id or not photos:
        return jsonify({'error': 'Claim ID and photos are required'}), 400

    claims_evidence_db.setdefault(claim_id, [])
    claims_evidence_db[claim_id].extend(photos)

    metadata_leak = any('gps' in str(photo).lower() for photo in photos)

    return jsonify({
        'claim_id': claim_id,
        'photos_received': len(photos),
        'total_evidence_items': len(claims_evidence_db[claim_id]),
        'metadata_detected': metadata_leak,
        'manual_review_required': metadata_leak or len(photos) > 5
    })


@app.route('/api/claims/bulk-export', methods=['POST'])
def claims_bulk_export():
    """Bulk export claims data - sensitive operation"""
    admin_token = request.headers.get('X-Claims-Admin')
    if admin_token != 'CLAIMS-EXPORT-KEY':
        return jsonify({'error': 'Claims admin authorization required'}), 403

    export_id = f"CLAIMS-EXPORT-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'export_id': export_id,
        'claims_count': len(claims_db),
        'evidence_items': sum(len(v) for v in claims_evidence_db.values()),
        'download_url': f"/downloads/{export_id}.zip",
        'expires_in': 900,
        'data_classification': 'restricted'
    })


@app.route('/api/claims/<claim_id>/status', methods=['PUT'])
def claims_status_update(claim_id):
    """Update the status of a claim"""
    data = request.get_json() or {}
    new_status = data.get('status')
    adjuster_id = data.get('adjuster_id', 'ADJ-UNKNOWN')

    claim = claims_db.get(claim_id)
    if not claim:
        return jsonify({'error': 'Claim not found'}), 404

    previous_status = claim.get('status', 'submitted')
    claim['status'] = new_status or previous_status
    claim['last_updated'] = datetime.now().isoformat()
    claim['adjuster_id'] = adjuster_id

    return jsonify({
        'claim_id': claim_id,
        'previous_status': previous_status,
        'new_status': claim['status'],
        'adjuster_id': adjuster_id,
        'status_change_allowed': True
    })


@app.route('/api/claims/duplicate', methods=['POST'])
def claims_duplicate():
    """Duplicate an existing claim - fraud scenario"""
    data = request.get_json() or {}
    source_claim_id = data.get('claim_id')

    source_claim = claims_db.get(source_claim_id)
    if not source_claim:
        return jsonify({'error': 'Source claim not found'}), 404

    new_claim_id = f"CLAIM-{uuid.uuid4().hex[:8].upper()}"
    duplicated_claim = dict(source_claim)
    duplicated_claim['claim_id'] = new_claim_id
    duplicated_claim['status'] = 'submitted'
    duplicated_claim['duplicated_from'] = source_claim_id
    duplicated_claim['submitted_at'] = datetime.now().isoformat()
    duplicated_claim['fraud_score'] = min(1.0, source_claim.get('fraud_score', 0.3) + 0.4)

    claims_db[new_claim_id] = duplicated_claim

    return jsonify({
        'new_claim_id': new_claim_id,
        'duplicated_from': source_claim_id,
        'fraud_score': duplicated_claim['fraud_score'],
        'flagged_for_review': True
    })


@app.route('/api/claims/fraud-indicators')
def claims_fraud_indicators():
    """Expose aggregated fraud indicators"""
    indicators = []
    for claim in claims_db.values():
        indicators.append({
            'claim_id': claim['claim_id'],
            'policy_number': claim['policy_number'],
            'fraud_score': claim.get('fraud_score', random.uniform(0.1, 0.9)),
            'indicators': claim.get('fraud_indicators', []),
            'last_updated': claim.get('last_updated', claim.get('submitted_at'))
        })

    return jsonify({
        'total_claims': len(indicators),
        'average_fraud_score': sum(item['fraud_score'] for item in indicators) / max(len(indicators), 1),
        'claims': indicators
    })


@app.route('/api/claims/expedite', methods=['POST'])
def claims_expedite():
    """Expedite a claim processing"""
    data = request.get_json() or {}
    claim_id = data.get('claim_id')
    justification = data.get('justification', '')

    claim = claims_db.get(claim_id)
    if not claim:
        return jsonify({'error': 'Claim not found'}), 404

    claim['expedited'] = True
    claim['expedite_justification'] = justification
    claim['estimated_processing'] = '24-48 hours'

    return jsonify({
        'claim_id': claim_id,
        'expedited': True,
        'justification': justification,
        'new_processing_eta': claim['estimated_processing']
    })


@app.route('/api/claims/amounts/inflate', methods=['PUT'])
def claims_amounts_inflate():
    """Artificially inflate claim amounts - abuse scenario"""
    data = request.get_json() or {}
    claim_id = data.get('claim_id')
    multiplier = float(data.get('multiplier', 1))

    claim = claims_db.get(claim_id)
    if not claim:
        return jsonify({'error': 'Claim not found'}), 404

    original_amount = claim['amount']
    claim['amount'] = round(original_amount * multiplier, 2)
    claim['inflated'] = True
    claim['inflation_multiplier'] = multiplier

    return jsonify({
        'claim_id': claim_id,
        'original_amount': original_amount,
        'inflated_amount': claim['amount'],
        'multiplier': multiplier,
        'detected': multiplier > 1.5
    })


@app.route('/api/customers/export')
def customers_export():
    """Export customer roster - sensitive data exfiltration"""
    segment = request.args.get('segment')

    customers = list(customers_db.values())
    if segment:
        customers = [c for c in customers if c['segment'] == segment]

    return jsonify({
        'customers': customers,
        'exported_at': datetime.now().isoformat(),
        'segment': segment,
        'total_customers': len(customers),
        'contains_sensitive_data': True
    })


@app.route('/api/policies/search')
def policies_search():
    """Policy search endpoint"""
    policy_type = request.args.get('type')
    status = request.args.get('status')

    results = []
    for policy in policies_db.values():
        if policy_type and policy['type'] != policy_type:
            continue
        if status and policy['status'] != status:
            continue
        results.append(policy)

    return jsonify({
        'policies': results,
        'filters': {'type': policy_type, 'status': status},
        'total': len(results)
    })


@app.route('/api/premiums/calculate', methods=['POST'])
def premiums_calculate():
    """Premium calculation endpoint"""
    data = request.get_json() or {}
    policy_type = data.get('policy_type', 'auto')
    base_premium = data.get('base_premium', 1000)
    risk_score = data.get('risk_score', 0.5)
    discounts = data.get('discounts', [])

    adjustment = 1 + (risk_score - 0.5)
    total_discount = sum(discounts)
    final_premium = max(0, base_premium * adjustment - total_discount)

    return jsonify({
        'policy_type': policy_type,
        'base_premium': base_premium,
        'risk_adjustment_multiplier': adjustment,
        'discount_total': total_discount,
        'final_premium': round(final_premium, 2)
    })


@app.route('/api/policies/coverage-limits', methods=['PUT'])
def policies_coverage_limits():
    """Policy coverage modification endpoint"""
    data = request.get_json() or {}
    policy_id = data.get('policy_id')
    new_limit = data.get('coverage_limit')
    justification = data.get('justification', '')

    policy = policies_db.get(policy_id)
    if not policy:
        return jsonify({'error': 'Policy not found'}), 404

    previous_limit = policy['coverage_limit']
    policy['coverage_limit'] = new_limit

    return jsonify({
        'policy_id': policy_id,
        'previous_limit': previous_limit,
        'new_limit': new_limit,
        'justification': justification,
        'requires_manager_approval': new_limit > previous_limit * 1.5
    })


@app.route('/api/underwriting/rules')
def underwriting_rules():
    """Underwriting rules enumeration"""
    return jsonify({
        'rules': underwriting_rules_db,
        'total_rules': len(underwriting_rules_db),
        'policy_types_impacted': ['auto', 'home', 'life']
    })


@app.route('/api/underwriting/override', methods=['POST'])
def underwriting_override():
    """Override underwriting decisions"""
    data = request.get_json() or {}
    policy_id = data.get('policy_id')
    rule_id = data.get('rule_id')
    reason = data.get('reason', 'manual_override')

    policy = policies_db.get(policy_id)
    if not policy:
        return jsonify({'error': 'Policy not found'}), 404

    override_id = f"UW-OVERRIDE-{uuid.uuid4().hex[:8]}"
    override_record = {
        'override_id': override_id,
        'rule_id': rule_id,
        'reason': reason,
        'timestamp': datetime.now().isoformat()
    }
    policy.setdefault('overrides', []).append(override_record)

    return jsonify({
        'override_id': override_id,
        'policy_id': policy_id,
        'rule_id': rule_id,
        'reason': reason,
        'audit_logged': False
    })


@app.route('/api/policies/pricing-models')
def policies_pricing_models():
    """Expose pricing models for policies"""
    models = [
        {
            'model_id': 'PRICING-AUTO-2025',
            'policy_type': 'auto',
            'version': '2025.1',
            'factors': ['driver_age', 'vehicle_value', 'claims_history'],
            'status': 'active'
        },
        {
            'model_id': 'PRICING-HOME-2025',
            'policy_type': 'home',
            'version': '2025.3',
            'factors': ['zip_code', 'construction_type', 'weather_risk'],
            'status': 'active'
        }
    ]

    return jsonify({
        'models': models,
        'total_models': len(models),
        'sensitivity': 'confidential'
    })


@app.route('/api/actuarial/models/modify', methods=['PUT'])
def actuarial_models_modify():
    """Modify actuarial models - tampering scenario"""
    data = request.get_json() or {}
    model_id = data.get('model_id')
    new_version = data.get('version')
    adjustment = data.get('adjustment_factor', 1.0)

    model = actuarial_models_db.get(model_id)
    if not model:
        return jsonify({'error': 'Model not found'}), 404

    previous_version = model['version']
    model['version'] = new_version or model['version']
    model['adjustment_factor'] = adjustment
    model['last_modified'] = datetime.now().isoformat()

    return jsonify({
        'model_id': model_id,
        'previous_version': previous_version,
        'new_version': model['version'],
        'adjustment_factor': adjustment,
        'model_status': model['status'],
        'alert_triggered': adjustment > 1.2
    })


@app.route('/api/risk/factors')
def risk_factors():
    """Risk factors enumeration endpoint"""
    return jsonify({
        'risk_factors': [
            {'factor_id': 'RF-001', 'name': 'age', 'weight': 0.15, 'category': 'demographic'},
            {'factor_id': 'RF-002', 'name': 'credit_score', 'weight': 0.25, 'category': 'financial'},
            {'factor_id': 'RF-003', 'name': 'location', 'weight': 0.20, 'category': 'geographic'},
            {'factor_id': 'RF-004', 'name': 'claims_history', 'weight': 0.30, 'category': 'behavioral'},
            {'factor_id': 'RF-005', 'name': 'occupation', 'weight': 0.10, 'category': 'demographic'}
        ],
        'total_factors': 5,
        'version': '2025.1',
        'sensitivity': 'confidential'
    })


@app.route('/api/policies/backdoor', methods=['POST'])
def policies_backdoor():
    """Policy backdoor access - administrative bypass"""
    data = request.get_json() or {}
    policy_id = data.get('policy_id')
    access_token = data.get('access_token', '')

    if access_token != 'POLICY-ADMIN-BACKDOOR':
        return jsonify({'error': 'Invalid access token'}), 403

    backdoor_token = f"BACKDOOR-{uuid.uuid4().hex[:12]}"

    return jsonify({
        'backdoor_granted': True,
        'policy_id': policy_id,
        'backdoor_token': backdoor_token,
        'privileges': ['view_all', 'modify_limits', 'bypass_underwriting', 'export_data'],
        'persistence': 'permanent',
        'audit_logged': False
    })


@app.route('/api/underwriting/export')
def underwriting_export():
    """Export underwriting data - data exfiltration vector"""
    format_type = request.args.get('format', 'json')
    policy_type = request.args.get('policy_type', 'all')

    export_data = {
        'export_id': f"UW-EXPORT-{uuid.uuid4().hex[:8]}",
        'policy_type': policy_type,
        'total_policies': len(policies_db),
        'underwriting_rules': underwriting_rules_db,
        'actuarial_models': list(actuarial_models_db.keys()),
        'export_format': format_type,
        'exported_at': datetime.now().isoformat(),
        'data_classification': 'highly_confidential',
        'download_url': f"/api/exports/download/{uuid.uuid4().hex}"
    }

    return jsonify(export_data)


@app.route('/api/risk/scores/manipulate', methods=['PUT'])
def risk_scores_manipulate():
    """Manipulate risk scores - fraud vector"""
    data = request.get_json() or {}
    policy_id = data.get('policy_id')
    new_score = data.get('risk_score', 0.5)
    reason = data.get('reason', 'manual_adjustment')

    policy = policies_db.get(policy_id)
    if not policy:
        return jsonify({'error': 'Policy not found'}), 404

    previous_score = policy.get('risk_score', 0.5)
    policy['risk_score'] = new_score
    policy['score_manipulated'] = True
    policy['manipulation_reason'] = reason

    return jsonify({
        'policy_id': policy_id,
        'previous_score': previous_score,
        'new_score': new_score,
        'score_changed': abs(new_score - previous_score) > 0.1,
        'reason': reason,
        'audit_logged': False,
        'alert_triggered': abs(new_score - previous_score) > 0.3
    })


@app.route('/api/policies/bulk-modify', methods=['POST'])
def policies_bulk_modify():
    """Bulk modify policies - mass manipulation vector"""
    data = request.get_json() or {}
    policy_ids = data.get('policy_ids', [])
    modifications = data.get('modifications', {})

    if not policy_ids:
        return jsonify({'error': 'No policy IDs provided'}), 400

    modified_count = 0
    failed_policies = []

    for policy_id in policy_ids:
        policy = policies_db.get(policy_id)
        if policy:
            for key, value in modifications.items():
                policy[key] = value
            modified_count += 1
        else:
            failed_policies.append(policy_id)

    return jsonify({
        'bulk_modification_id': f"BULK-MOD-{uuid.uuid4().hex[:8]}",
        'total_requested': len(policy_ids),
        'modified': modified_count,
        'failed': len(failed_policies),
        'failed_policies': failed_policies,
        'modifications_applied': modifications,
        'audit_logged': False,
        'timestamp': datetime.now().isoformat()
    })

# =============================================================================
# API GATEWAY & OAUTH ENDPOINTS
# =============================================================================

@app.route('/api/gateway/routes')
def gateway_routes():
    """Route enumeration - potential reconnaissance target"""
    return jsonify({
        'routes': [
            {'path': '/api/v1/auth/*', 'service': 'authentication', 'methods': ['GET', 'POST']},
            {'path': '/api/v1/accounts/*', 'service': 'banking', 'methods': ['GET', 'POST', 'PUT']},
            {'path': '/api/payments/*', 'service': 'payments', 'methods': ['POST']},
            {'path': '/api/claims/*', 'service': 'insurance', 'methods': ['GET', 'POST', 'PUT']},
            {'path': '/api/admin/*', 'service': 'administration', 'methods': ['GET', 'POST', 'PUT', 'DELETE']},
        ],
        'gateway_version': '2.1.0',
        'total_routes': 47
    })

@app.route('/api/oauth/authorize')
def oauth_authorize():
    """OAuth authorization endpoint"""
    client_id = request.args.get('client_id', '')
    redirect_uri = request.args.get('redirect_uri', '')
    response_type = request.args.get('response_type', 'code')

    # Basic OAuth flow simulation
    if not client_id:
        return jsonify({'error': 'Missing client_id'}), 400

    # Generate authorization code
    auth_code = f"AUTH-{uuid.uuid4().hex[:16]}"

    return jsonify({
        'authorization_code': auth_code,
        'expires_in': 600,
        'state': request.args.get('state', ''),
        'redirect_uri': redirect_uri
    })

@app.route('/api/oauth/token', methods=['POST'])
def oauth_token():
    """OAuth token endpoint"""
    data = request.get_json() or {}
    grant_type = data.get('grant_type', '')

    if grant_type == 'authorization_code':
        access_token = f"ACCESS-{uuid.uuid4().hex}"
        refresh_token = f"REFRESH-{uuid.uuid4().hex}"

        return jsonify({
            'access_token': access_token,
            'refresh_token': refresh_token,
            'token_type': 'Bearer',
            'expires_in': 3600,
            'scope': 'read write'
        })

    return jsonify({'error': 'Unsupported grant type'}), 400

@app.route('/api/microservices/mesh')
def microservices_mesh():
    """Service mesh discovery"""
    return jsonify({
        'services': [
            {'name': 'auth-service', 'status': 'healthy', 'instances': 3},
            {'name': 'payment-service', 'status': 'healthy', 'instances': 2},
            {'name': 'notification-service', 'status': 'degraded', 'instances': 1},
            {'name': 'analytics-service', 'status': 'healthy', 'instances': 4}
        ],
        'mesh_version': '1.8.2',
        'total_services': 12
    })


# =============================================================================
# CLOUD-NATIVE & MICROSERVICES EXPLOITATION ENDPOINTS
# =============================================================================

@app.route('/api/gateway/discovery')
def gateway_discovery():
    """Discover API gateway configuration"""
    return jsonify({
        'services': cloud_service_registry.get('discovery', []),
        'policies': cloud_service_registry.get('policies', []),
        'exposed_headers': ['x-envoy-original-path', 'x-forwarded-for'],
        'sensitive_services': cloud_service_registry.get('sensitive_services', [])
    })


@app.route('/api/gateway/routes/poison', methods=['POST'])
def gateway_routes_poison():
    """Poison gateway routes"""
    data = request.get_json() or {}
    route = data.get('route', '/api/*')
    destination = data.get('destination', 'malicious-service')

    return jsonify({
        'route_poisoned': True,
        'route': route,
        'new_destination': destination,
        'shadow_mode': data.get('shadow_mode', True),
        'detection_risk': 'medium'
    })


@app.route('/api/microservices/intercept', methods=['POST'])
def microservices_intercept():
    """Intercept microservice communications"""
    data = request.get_json() or {}
    service = data.get('service', 'auth-service')
    technique = data.get('technique', 'traffic_mirroring')

    return jsonify({
        'service': service,
        'intercept_method': technique,
        'tls_termination': True,
        'session_keys_exposed': True,
        'duration_seconds': 600
    })


@app.route('/api/service-discovery')
def service_discovery():
    """Service discovery endpoint"""
    services = [
        {'name': 'billing-service', 'version': '2.4.1', 'ip': '10.0.3.12'},
        {'name': 'analytics-service', 'version': '1.10.0', 'ip': '10.0.4.8'},
        {'name': 'user-profile', 'version': '3.2.5', 'ip': '10.0.5.4'}
    ]
    return jsonify({
        'services': services,
        'registry': 'consul',
        'last_synced': datetime.now().isoformat()
    })


@app.route('/api/containers/escape', methods=['POST'])
def containers_escape():
    """Container escape attempt"""
    data = request.get_json() or {}
    container_id = data.get('container_id', 'demo-container')
    method = data.get('method', 'cgroup_breakout')

    return jsonify({
        'container_id': container_id,
        'escape_method': method,
        'host_access_gained': True,
        'privilege_level': 'root',
        'audit_logs_wiped': True
    })


@app.route('/api/containers/registry')
def containers_registry():
    """Enumerate container registry"""
    images = [
        {'image': 'chimera/api:latest', 'vulnerabilities': 12, 'last_scan': '2025-09-01'},
        {'image': 'chimera/web:stable', 'vulnerabilities': 4, 'last_scan': '2025-08-22'},
        {'image': 'chimera/worker:canary', 'vulnerabilities': 18, 'last_scan': 'never'}
    ]
    return jsonify({
        'registry': 'registry.chimera.local',
        'images': images,
        'total_images': len(images),
        'anonymous_pull_enabled': True
    })


@app.route('/api/rbac/impersonate', methods=['POST'])
def rbac_impersonate():
    """Impersonate RBAC roles"""
    data = request.get_json() or {}
    service_account = data.get('service_account', 'default')
    namespace = data.get('namespace', 'default')

    return jsonify({
        'service_account': service_account,
        'namespace': namespace,
        'impersonation_token': f"imp-{uuid.uuid4().hex[:12]}",
        'cluster_admin': True,
        'audit_logged': False
    })


@app.route('/api/pods/create', methods=['POST'])
def pods_create():
    """Create malicious pods"""
    data = request.get_json() or {}
    namespace = data.get('namespace', 'default')
    replicas = data.get('replicas', 1)

    return jsonify({
        'namespace': namespace,
        'replicas_created': replicas,
        'image': data.get('image', 'busybox'),
        'privileged': data.get('privileged', True),
        'host_network': True
    })


@app.route('/api/secrets/kubernetes')
def secrets_kubernetes():
    """Expose Kubernetes secrets"""
    return jsonify({
        'secrets': [
            {'name': 'db-credentials', 'namespace': 'prod', 'data': 'base64::c3VwZXJzZWNyZXQ='},
            {'name': 'api-keys', 'namespace': 'default', 'data': 'base64::YXBpa2V5PTQxMTExMQ=='}
        ],
        'encryption_at_rest': False,
        'service_accounts_exposed': True
    })


@app.route('/api/network/policies/bypass', methods=['POST'])
def network_policies_bypass():
    """Bypass cluster network policies"""
    data = request.get_json() or {}
    namespace = data.get('namespace', 'default')
    strategy = data.get('strategy', 'spoof_labels')

    return jsonify({
        'namespace': namespace,
        'strategy': strategy,
        'bypass_successful': True,
        'exfiltration_paths': ['database', 'metrics-server', 'external-api'],
        'detection_probability': 'low'
    })


@app.route('/api/monitoring/metrics')
def monitoring_metrics():
    """Extract monitoring metrics"""
    metrics = {
        'cpu_usage': random.uniform(10, 95),
        'memory_usage': random.uniform(20, 90),
        'request_rate': random.uniform(100, 1000),
        'error_rate': random.uniform(0, 5)
    }
    return jsonify({
        'metrics': metrics,
        'timestamp': datetime.now().isoformat(),
        'sensitive_dimensions': ['customer_id', 'session_id']
    })


@app.route('/api/gateway/backdoor', methods=['POST'])
def gateway_backdoor():
    """Install gateway backdoor"""
    data = request.get_json() or {}
    backdoor_key = data.get('key', 'gw-backdoor')

    return jsonify({
        'backdoor_deployed': True,
        'key': backdoor_key,
        'capabilities': ['route_injection', 'auth_bypass', 'traffic_clone'],
        'persistence': 'daemonset'
    })


@app.route('/api/configurations/tamper', methods=['PUT'])
def configurations_tamper():
    """Tamper with configuration files"""
    data = request.get_json() or {}
    config_path = data.get('config_path', '/etc/configmap')
    modification = data.get('modification', 'inject_proxy')

    return jsonify({
        'config_path': config_path,
        'modification': modification,
        'reload_triggered': True,
        'rollback_available': False
    })
# =============================================================================
# ADVANCED PERSISTENT THREAT (APT) ENDPOINTS
# =============================================================================

@app.route('/api/recon/advanced')
def recon_advanced():
    """Advanced reconnaissance data"""
    data = {
        'external_services': ['vpn-gateway', 'hr-portal', 'finance-sftp'],
        'tech_stack': ['kubernetes', 'istio', 'postgres', 'redis'],
        'high_value_targets': ['cfo@chimera.com', 'security@chimera.com']
    }
    apt_operations_log.append({'type': 'recon', 'data': data, 'timestamp': datetime.now().isoformat()})
    return jsonify(data)


@app.route('/api/infrastructure/mapping')
def infrastructure_mapping():
    """Infrastructure mapping endpoint"""
    return jsonify({
        'subnets': ['10.0.0.0/24', '10.0.1.0/24', '10.0.2.0/24'],
        'vpn_endpoints': ['vpn.chimera.local', 'vpn2.chimera.local'],
        'cloud_accounts': ['aws-chimera-prod', 'azure-chimera-bcp']
    })


@app.route('/api/intelligence/gather', methods=['POST'])
def intelligence_gather():
    """Gather internal intelligence"""
    data = request.get_json() or {}
    target = data.get('target', 'executive')
    apt_operations_log.append({'type': 'intelligence', 'target': target, 'timestamp': datetime.now().isoformat()})
    return jsonify({
        'target': target,
        'intel_gathered': ['calendar_entries', 'travel_itineraries', 'org_charts'],
        'cred_leak_detected': True
    })


@app.route('/api/employees/directory')
def employees_directory():
    """Enumerate employees"""
    employees = [
        {'name': 'Alice Johnson', 'email': 'alice.johnson@chimera.com', 'role': 'Security Engineer'},
        {'name': 'Bob Williams', 'email': 'bob.williams@chimera.com', 'role': 'Finance Manager'}
    ]
    return jsonify({'employees': employees, 'total': len(employees), 'sensitive': True})


@app.route('/api/technologies/stack')
def technologies_stack():
    """Expose technology stack"""
    return jsonify({
        'frontend': ['React', 'Next.js'],
        'backend': ['Flask', 'Node.js', 'Go'],
        'infrastructure': ['Kubernetes', 'Terraform', 'Vault'],
        'ci_cd': ['GitHub Actions', 'ArgoCD']
    })


@app.route('/api/social/engineering', methods=['POST'])
def social_engineering():
    """Launch social engineering campaign"""
    data = request.get_json() or {}
    campaign_id = f"SOC-{uuid.uuid4().hex[:8]}"
    apt_operations_log.append({'type': 'social', 'campaign': campaign_id, 'timestamp': datetime.now().isoformat()})
    return jsonify({
        'campaign_id': campaign_id,
        'targets': data.get('targets', ['employees']),
        'success_probability': random.uniform(0.2, 0.9)
    })


@app.route('/api/network/topology')
def network_topology():
    """Network topology exposure"""
    return jsonify({
        'core_switches': ['core-1', 'core-2'],
        'firewalls': ['fw-east', 'fw-west'],
        'dmz_services': ['reverse-proxy', 'secure-mail'],
        'links': 48
    })


@app.route('/api/vulnerabilities/scan', methods=['POST'])
def vulnerabilities_scan():
    """Trigger vulnerability scans"""
    data = request.get_json() or {}
    scope = data.get('scope', ['external', 'internal'])
    findings = [
        {'id': 'CVE-2025-1234', 'severity': 'critical', 'asset': 'vpn-gateway'},
        {'id': 'CVE-2024-2443', 'severity': 'high', 'asset': 'billing-service'}
    ]
    return jsonify({
        'scan_scope': scope,
        'findings': findings,
        'scan_id': f"SCAN-{uuid.uuid4().hex[:8]}",
        'export_ready': True
    })


@app.route('/api/lateral/movement', methods=['POST'])
def lateral_movement():
    """Simulate lateral movement"""
    data = request.get_json() or {}
    start_host = data.get('start_host', 'workstation-01')
    path = ['workstation-01', 'file-server', 'domain-controller']
    return jsonify({
        'start_host': start_host,
        'movement_path': path,
        'credentials_used': ['svc-backup', 'svc-monitor'],
        'detected': False
    })


@app.route('/api/privilege/escalation', methods=['POST'])
def privilege_escalation():
    """Privilege escalation attempt"""
    data = request.get_json() or {}
    exploit = data.get('exploit', 'kernel_priv_esc')
    return jsonify({
        'exploit_used': exploit,
        'escalated_to': 'domain_admin',
        'persistence_installed': True,
        'credential_dump': ['krbtgt', 'administrator']
    })


@app.route('/api/credentials/harvest')
def credentials_harvest():
    """Harvest credentials listing"""
    return jsonify({
        'credentials': [
            {'user': 'svc-backup', 'password': 'P@ssw0rd1!', 'privilege': 'high'},
            {'user': 'db-admin', 'password': 'Summer2025!', 'privilege': 'critical'}
        ],
        'hashes_exposed': True
    })


@app.route('/api/persistence/establish', methods=['POST'])
def persistence_establish():
    """Establish persistence"""
    data = request.get_json() or {}
    technique = data.get('technique', 'scheduled_task')
    return jsonify({
        'persistence_technique': technique,
        'survives_reboot': True,
        'cleanup_script_present': False
    })


@app.route('/api/network/shares')
def network_shares():
    """List network shares"""
    shares = [
        {'path': '\\fileserver\\finance', 'sensitivity': 'high'},
        {'path': '\\fileserver\\engineering', 'sensitivity': 'critical'}
    ]
    return jsonify({'shares': shares, 'total_shares': len(shares), 'exfiltration_ready': True})


@app.route('/api/backdoors/install', methods=['POST'])
def backdoors_install():
    """Install system backdoors"""
    data = request.get_json() or {}
    host = data.get('host', 'domain-controller')
    return jsonify({
        'host': host,
        'backdoor_id': f"BD-{uuid.uuid4().hex[:10]}",
        'persistence': 'registry_run_key',
        'covert_channel': 'dns_tunneling'
    })


@app.route('/api/domain/admin/impersonate')
def domain_admin_impersonate():
    """Domain admin impersonation"""
    return jsonify({
        'impersonated_account': 'administrator@chimera.local',
        'kerberos_ticket': 'base64::S0VSQkVST1M=',
        'valid_until': (datetime.now() + timedelta(hours=8)).isoformat()
    })


@app.route('/api/certificates/forge', methods=['POST'])
def certificates_forge():
    """Forge certificates"""
    data = request.get_json() or {}
    cn = data.get('common_name', 'auth.chimera.local')
    return jsonify({
        'certificate_cn': cn,
        'valid_from': datetime.now().isoformat(),
        'valid_to': (datetime.now() + timedelta(days=365)).isoformat(),
        'signature_algorithm': 'SHA1withRSA',
        'trusted': False
    })


@app.route('/api/compliance/bypass', methods=['POST'])
def compliance_bypass():
    """Bypass compliance controls"""
    data = request.get_json() or {}
    control = data.get('control', 'SOX-404')
    return jsonify({
        'control': control,
        'bypass_successful': True,
        'audit_alert_suppressed': True,
        'residual_risk': 'critical'
    })


@app.route('/api/audit/trails', methods=['PUT'])
def audit_trails_put():
    """Modify audit trails"""
    data = request.get_json() or {}
    entries_modified = len(data.get('entries', []))
    return jsonify({
        'entries_modified': entries_modified,
        'tamper_successful': True,
        'forensic_visibility': 'none'
    })


@app.route('/api/logs/deletion', methods=['POST'])
def logs_deletion():
    """Delete logs"""
    data = request.get_json() or {}
    systems = data.get('systems', ['siem', 'firewall'])
    return jsonify({
        'systems_targeted': systems,
        'logs_deleted': True,
        'recovery_possible': False
    })


@app.route('/api/security/monitoring/bypass')
def security_monitoring_bypass():
    """Bypass security monitoring"""
    return jsonify({
        'strategies': ['log_suppression', 'traffic_obfuscation', 'alert_saturation'],
        'monitoring_disabled': True,
        'duration_minutes': 45
    })


@app.route('/api/forensics/anti', methods=['POST'])
def forensics_anti():
    """Anti-forensics operations"""
    data = request.get_json() or {}
    techniques = data.get('techniques', ['timestamp_manipulation'])
    return jsonify({
        'techniques': techniques,
        'effectiveness': 'high',
        'evidence_destroyed': True
    })


@app.route('/api/timestamps/modify', methods=['PUT'])
def timestamps_modify():
    """Modify timestamps"""
    data = request.get_json() or {}
    offset_minutes = data.get('offset_minutes', -120)
    return jsonify({
        'offset_minutes': offset_minutes,
        'files_modified': data.get('files', 25),
        'detection_risk': 'medium'
    })


@app.route('/api/evidence/destroy', methods=['POST'])
def evidence_destroy():
    """Destroy forensic evidence"""
    data = request.get_json() or {}
    targets = data.get('targets', ['memory_dumps', 'packet_captures'])
    return jsonify({
        'targets': targets,
        'successful': True,
        'irrecoverable': True
    })


@app.route('/api/incident/response/disrupt')
def incident_response_disrupt():
    """Disrupt incident response"""
    return jsonify({
        'playbooks_disabled': ['containment', 'eradication'],
        'communication_channels': ['slack', 'pagerduty'],
        'mttr_increase_minutes': 180
    })


# =============================================================================
# ADDITIONAL ENDPOINTS FOR COMPREHENSIVE COVERAGE
# =============================================================================

@app.route('/api/system/version')
def system_version():
    """System version endpoint for fingerprinting"""
    return jsonify({
        'application': ' Demo Platform',
        'version': '2.1.0',
        'build': '20241201-1234',
        'environment': 'demo',
        'frameworks': ['Flask', 'Python3.9'],
        'database': 'in-memory'
    })

@app.route('/api/admin/users/create', methods=['POST'])
def admin_create_user():
    """Administrative user creation - backdoor potential"""
    # This endpoint simulates a vulnerable admin function
    admin_key = request.headers.get('X-Admin-Key')

    if admin_key != 'admin-demo-key':
        return jsonify({'error': 'Invalid admin key'}), 403

    data = request.get_json()
    username = data.get('username', '')

    if username:
        user_id = f"admin_{uuid.uuid4().hex[:8]}"
        return jsonify({
            'success': True,
            'user_id': user_id,
            'username': username,
            'privileges': 'administrator',
            'created_at': datetime.now().isoformat()
        })

    return jsonify({'error': 'Username required'}), 400

@app.route('/api/webhooks/register', methods=['POST'])
def webhooks_register():
    """Webhook registration for persistence"""
    data = request.get_json()
    callback_url = data.get('callback_url', '')

    webhook_id = f"WEBHOOK-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'success': True,
        'webhook_id': webhook_id,
        'callback_url': callback_url,
        'events': ['payment.completed', 'claim.submitted', 'auth.failed'],
        'secret': f"whsec_{uuid.uuid4().hex[:16]}"
    })

# Payment Processing Endpoints (Missing)

@app.route('/api/payments/authorize', methods=['POST'])
def payments_authorize():
    """Payment authorization endpoint"""
    data = request.get_json()
    card_number = data.get('card_number', '')
    amount = float(data.get('amount', 0))

    auth_code = f"AUTH-{uuid.uuid4().hex[:8].upper()}"

    return jsonify({
        'authorized': True,
        'authorization_code': auth_code,
        'amount': amount,
        'currency': 'USD',
        'card_last_four': card_number[-4:] if len(card_number) >= 4 else '****',
        'timestamp': datetime.now().isoformat()
    })

@app.route('/api/payments/capture', methods=['POST'])
def payments_capture():
    """Payment capture endpoint"""
    data = request.get_json()
    auth_code = data.get('authorization_code', '')
    amount = float(data.get('amount', 0))

    transaction_id = f"TXN-{uuid.uuid4().hex[:12].upper()}"

    return jsonify({
        'captured': True,
        'transaction_id': transaction_id,
        'authorization_code': auth_code,
        'amount': amount,
        'status': 'completed',
        'timestamp': datetime.now().isoformat()
    })

@app.route('/api/merchant/transactions')
def merchant_transactions():
    """Merchant transaction history"""
    merchant_id = request.args.get('merchant_id', 'MERCH-DEMO')
    limit = int(request.args.get('limit', 50))

    transactions = [
        {
            'transaction_id': f"TXN-{uuid.uuid4().hex[:12].upper()}",
            'amount': random.uniform(10, 500),
            'currency': 'USD',
            'status': random.choice(['completed', 'pending', 'refunded']),
            'timestamp': (datetime.now() - timedelta(hours=random.randint(1, 72))).isoformat()
        }
        for _ in range(min(limit, 50))
    ]

    return jsonify({
        'merchant_id': merchant_id,
        'transaction_count': len(transactions),
        'transactions': transactions
    })

@app.route('/api/payments/refund', methods=['POST'])
def payments_refund():
    """Payment refund processing"""
    data = request.get_json()
    transaction_id = data.get('transaction_id', '')
    amount = float(data.get('amount', 0))
    reason = data.get('reason', 'customer_request')

    refund_id = f"REFUND-{uuid.uuid4().hex[:10].upper()}"

    return jsonify({
        'refunded': True,
        'refund_id': refund_id,
        'transaction_id': transaction_id,
        'amount': amount,
        'reason': reason,
        'status': 'processed',
        'estimated_arrival': '5-10 business days',
        'timestamp': datetime.now().isoformat()
    })

@app.route('/api/payments/gateway/status')
def payments_gateway_status():
    """Payment gateway status check"""
    return jsonify({
        'status': 'operational',
        'uptime_percentage': 99.97,
        'response_time_ms': random.randint(50, 200),
        'active_connections': random.randint(100, 1000),
        'processors': {
            'stripe': 'online',
            'square': 'online',
            'paypal': 'degraded'
        },
        'last_incident': '2025-09-15T10:30:00Z'
    })

@app.route('/api/merchant/accounts/create', methods=['POST'])
def merchant_accounts_create():
    """Merchant account creation"""
    data = request.get_json()
    business_name = data.get('business_name', '')
    tax_id = data.get('tax_id', '')

    merchant_id = f"MERCH-{uuid.uuid4().hex[:8].upper()}"

    return jsonify({
        'created': True,
        'merchant_id': merchant_id,
        'business_name': business_name,
        'status': 'pending_verification',
        'account_type': 'standard',
        'approval_estimate': '3-5 business days',
        'onboarding_url': f'https://demo.site/merchant/onboard/{merchant_id}'
    })

@app.route('/api/payments/fraud-rules')
def payments_fraud_rules():
    """Fraud detection rules disclosure"""
    return jsonify({
        'fraud_detection_enabled': True,
        'rules': [
            {'rule_id': 'FR-001', 'type': 'velocity_check', 'threshold': '5 transactions per minute'},
            {'rule_id': 'FR-002', 'type': 'amount_limit', 'threshold': '$10,000 per transaction'},
            {'rule_id': 'FR-003', 'type': 'geo_blocking', 'countries': ['XX', 'YY']},
            {'rule_id': 'FR-004', 'type': 'bin_range', 'action': 'manual_review'},
            {'rule_id': 'FR-005', 'type': 'cvv_mismatch', 'action': 'decline'}
        ],
        'ml_model_version': '2.3.1',
        'last_updated': '2025-10-01T00:00:00Z'
    })

@app.route('/api/payments/bulk-process', methods=['POST'])
def payments_bulk_process():
    """Bulk payment processing"""
    data = request.get_json()
    payments = data.get('payments', [])

    batch_id = f"BATCH-{uuid.uuid4().hex[:10].upper()}"

    results = [
        {
            'payment_index': idx,
            'transaction_id': f"TXN-{uuid.uuid4().hex[:12].upper()}",
            'status': 'processed',
            'amount': payment.get('amount', 0)
        }
        for idx, payment in enumerate(payments[:100])  # Limit to 100
    ]

    return jsonify({
        'batch_id': batch_id,
        'total_payments': len(payments),
        'processed_count': len(results),
        'failed_count': 0,
        'results': results,
        'processing_time_ms': random.randint(500, 3000)
    })

@app.route('/api/cards/data/export')
def cards_data_export():
    """Card data extraction endpoint (intentional vulnerability)"""
    export_format = request.args.get('format', 'json')

    # ‚ö†Ô∏è INTENTIONAL VULNERABILITY FOR WAF TESTING
    # DO NOT USE IN PRODUCTION - Exposes card data
    card_data = [
        {
            'card_id': f"CARD-{uuid.uuid4().hex[:8]}",
            'card_number_masked': f"****-****-****-{random.randint(1000, 9999)}",
            'cardholder_name': f"Customer {random.randint(1, 1000)}",
            'expiry': f"{random.randint(1, 12):02d}/{random.randint(25, 30)}",
            'card_type': random.choice(['visa', 'mastercard', 'amex'])
        }
        for _ in range(50)
    ]

    return jsonify({
        'export_id': f"EXP-{uuid.uuid4().hex[:10].upper()}",
        'format': export_format,
        'record_count': len(card_data),
        'cards': card_data,
        'exported_at': datetime.now().isoformat()
    })

@app.route('/api/merchant/limits/override', methods=['PUT'])
def merchant_limits_override():
    """Merchant limit bypass (intentional vulnerability)"""
    data = request.get_json()
    merchant_id = data.get('merchant_id', '')
    new_limit = float(data.get('new_limit', 0))

    # ‚ö†Ô∏è INTENTIONAL VULNERABILITY FOR WAF TESTING
    return jsonify({
        'success': True,
        'merchant_id': merchant_id,
        'previous_limit': 10000.00,
        'new_limit': new_limit,
        'override_reason': 'Administrative override',
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/loyalty/program/details')
def loyalty_program_details():
    """Get loyalty program details with tier benefits"""
    return jsonify({
        'program_name': ' Rewards Plus',
        'tiers': [
            {'name': 'bronze', 'min_points': 0, 'benefits': ['5% cashback', 'birthday bonus']},
            {'name': 'silver', 'min_points': 5000, 'benefits': ['10% cashback', 'priority support', 'free shipping']},
            {'name': 'gold', 'min_points': 15000, 'benefits': ['15% cashback', 'concierge service', 'exclusive events']},
            {'name': 'platinum', 'min_points': 50000, 'benefits': ['20% cashback', 'dedicated manager', 'VIP lounge access']}
        ],
        'points_expiry_days': 365,
        'enrollment_bonus': 1000,
        'referral_bonus': 500
    })


@app.route('/api/loyalty/points/exchange-rates')
def loyalty_points_exchange_rates():
    """Get current points exchange rates"""
    # ‚ö†Ô∏è WARNING: Exposes internal conversion rates that could be manipulated
    return jsonify({
        'base_currency': 'USD',
        'exchange_rates': {
            'points_to_usd': 0.01,
            'usd_to_points': 100,
            'points_to_gift_card': 0.012,
            'miles_to_points': 1.5,
            'points_to_miles': 0.66
        },
        'minimum_redemption': 1000,
        'maximum_redemption': 100000,
        'rate_last_updated': datetime.now().isoformat()
    })


@app.route('/api/loyalty/tiers/requirements')
def loyalty_tiers_requirements():
    """Get tier qualification requirements"""
    return jsonify({
        'tiers': [
            {
                'tier': 'bronze',
                'annual_spend': 0,
                'points_earned': 0,
                'retention_period_days': 365
            },
            {
                'tier': 'silver',
                'annual_spend': 2500,
                'points_earned': 5000,
                'retention_period_days': 365
            },
            {
                'tier': 'gold',
                'annual_spend': 7500,
                'points_earned': 15000,
                'retention_period_days': 365
            },
            {
                'tier': 'platinum',
                'annual_spend': 25000,
                'points_earned': 50000,
                'retention_period_days': 730
            }
        ],
        'tier_downgrade_grace_period_days': 90
    })


@app.route('/api/auth/register', methods=['POST'])
def auth_register():
    """User registration endpoint"""
    # ‚ö†Ô∏è WARNING: Weak validation allows duplicate accounts and credential stuffing
    data = request.get_json() or {}
    email = data.get('email', '')
    password = data.get('password', '')
    name = data.get('name', '')

    if not email or not password:
        return jsonify({'error': 'Email and password required'}), 400

    user_id = f"user_{uuid.uuid4().hex[:8]}"
    users_db[email] = {
        'id': user_id,
        'email': email,
        'password': password,  # ‚ö†Ô∏è Storing plaintext password
        'name': name,
        'created': datetime.now().isoformat(),
        'email_verified': False
    }

    # Auto-create loyalty account
    loyalty_accounts_db[user_id] = {
        'points_balance': 1000,  # Welcome bonus
        'tier': 'bronze',
        'joined_date': datetime.now().isoformat()
    }

    return jsonify({
        'user_id': user_id,
        'email': email,
        'welcome_bonus_points': 1000,
        'account_verified': False,
        'verification_required': True
    })


@app.route('/api/loyalty/points/redeem', methods=['PUT'])
def loyalty_points_redeem():
    """Redeem loyalty points for rewards"""
    # ‚ö†Ô∏è WARNING: No fraud detection or rate limiting on redemptions
    data = request.get_json() or {}
    customer_id = data.get('customer_id')
    points = int(data.get('points', 0))
    reward_type = data.get('reward_type', 'cash')

    if not customer_id or points <= 0:
        return jsonify({'error': 'Invalid redemption request'}), 400

    account = loyalty_accounts_db.get(customer_id, {'points_balance': 0, 'tier': 'bronze'})

    if account['points_balance'] < points:
        return jsonify({'error': 'Insufficient points'}), 400

    loyalty_accounts_db[customer_id] = account
    account['points_balance'] -= points

    redemption_id = f"REDEEM-{uuid.uuid4().hex[:8]}"
    value_usd = points * 0.01  # ‚ö†Ô∏è Hardcoded rate, could be exploited

    return jsonify({
        'redemption_id': redemption_id,
        'points_redeemed': points,
        'reward_type': reward_type,
        'value_usd': value_usd,
        'remaining_balance': account['points_balance'],
        'processed_at': datetime.now().isoformat()
    })


@app.route('/api/loyalty/tiers/status', methods=['PUT'])
def loyalty_tiers_status():
    """Update customer tier status"""
    # ‚ö†Ô∏è WARNING: No authorization check - allows tier manipulation
    data = request.get_json() or {}
    customer_id = data.get('customer_id')
    new_tier = data.get('tier', 'bronze')

    if not customer_id:
        return jsonify({'error': 'Customer ID required'}), 400

    account = loyalty_accounts_db.get(customer_id, {'points_balance': 0, 'tier': 'bronze'})
    old_tier = account['tier']
    account['tier'] = new_tier
    loyalty_accounts_db[customer_id] = account

    return jsonify({
        'customer_id': customer_id,
        'previous_tier': old_tier,
        'new_tier': new_tier,
        'tier_updated': True,
        'benefits_unlocked': new_tier in ['gold', 'platinum'],
        'updated_at': datetime.now().isoformat()
    })


@app.route('/api/referrals/system/reward', methods=['POST'])
def referrals_system_reward():
    """Process referral rewards"""
    # ‚ö†Ô∏è WARNING: No validation allows self-referrals and duplicate claims
    data = request.get_json() or {}
    referrer_id = data.get('referrer_id')
    referred_id = data.get('referred_id')
    reward_points = int(data.get('reward_points', 500))

    if not referrer_id or not referred_id:
        return jsonify({'error': 'Referrer and referred IDs required'}), 400

    # Award points to referrer
    referrer_account = loyalty_accounts_db.get(referrer_id, {'points_balance': 0, 'tier': 'bronze'})
    referrer_account['points_balance'] += reward_points
    loyalty_accounts_db[referrer_id] = referrer_account

    # Award bonus to referred
    referred_account = loyalty_accounts_db.get(referred_id, {'points_balance': 0, 'tier': 'bronze'})
    referred_account['points_balance'] += reward_points // 2
    loyalty_accounts_db[referred_id] = referred_account

    referral_id = f"REF-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'referral_id': referral_id,
        'referrer_id': referrer_id,
        'referred_id': referred_id,
        'referrer_reward': reward_points,
        'referred_reward': reward_points // 2,
        'fraud_check_passed': True,  # ‚ö†Ô∏è Always passes
        'processed_at': datetime.now().isoformat()
    })


@app.route('/api/cashback/process', methods=['POST'])
def cashback_process():
    """Process cashback rewards"""
    # ‚ö†Ô∏è WARNING: No transaction verification or amount limits
    data = request.get_json() or {}
    customer_id = data.get('customer_id')
    transaction_amount = float(data.get('transaction_amount', 0))
    cashback_rate = float(data.get('cashback_rate', 0.05))

    if not customer_id or transaction_amount <= 0:
        return jsonify({'error': 'Invalid cashback request'}), 400

    cashback_amount = transaction_amount * cashback_rate
    points_earned = int(cashback_amount * 100)

    account = loyalty_accounts_db.get(customer_id, {'points_balance': 0, 'tier': 'bronze'})
    account['points_balance'] += points_earned
    loyalty_accounts_db[customer_id] = account

    cashback_id = f"CB-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'cashback_id': cashback_id,
        'customer_id': customer_id,
        'transaction_amount': transaction_amount,
        'cashback_rate': cashback_rate,
        'cashback_amount': cashback_amount,
        'points_earned': points_earned,
        'new_balance': account['points_balance'],
        'processed_at': datetime.now().isoformat()
    })


@app.route('/api/loyalty/accounts/link', methods=['POST'])
def loyalty_accounts_link():
    """Link external loyalty accounts"""
    # ‚ö†Ô∏è WARNING: No verification of account ownership or duplicate linking
    data = request.get_json() or {}
    primary_account = data.get('primary_account_id')
    external_account = data.get('external_account_id')
    external_program = data.get('external_program', 'partner')

    if not primary_account or not external_account:
        return jsonify({'error': 'Account IDs required'}), 400

    link_id = f"LINK-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'link_id': link_id,
        'primary_account': primary_account,
        'external_account': external_account,
        'external_program': external_program,
        'link_status': 'active',
        'points_sync_enabled': True,
        'sync_ratio': '1:1',
        'linked_at': datetime.now().isoformat()
    })


@app.route('/api/loyalty/rewards/gift-cards')
def loyalty_rewards_gift_cards():
    """List available gift card rewards"""
    return jsonify({
        'gift_cards': [
            {'merchant': 'Amazon', 'denominations': [25, 50, 100, 250], 'points_required': [2500, 5000, 10000, 25000]},
            {'merchant': 'Starbucks', 'denominations': [10, 25, 50], 'points_required': [1000, 2500, 5000]},
            {'merchant': 'Target', 'denominations': [25, 50, 100], 'points_required': [2500, 5000, 10000]},
            {'merchant': 'Best Buy', 'denominations': [50, 100, 250], 'points_required': [5000, 10000, 25000]},
            {'merchant': 'iTunes', 'denominations': [15, 25, 50], 'points_required': [1500, 2500, 5000]}
        ],
        'digital_delivery': True,
        'physical_delivery_fee_points': 500,
        'expiration_days': 365
    })


@app.route('/api/loyalty/customers/export')
def loyalty_customers_export():
    """Export customer loyalty data"""
    # ‚ö†Ô∏è WARNING: Bulk PII export without authorization or audit logging
    export_format = request.args.get('format', 'json')
    include_pii = request.args.get('include_pii', 'true').lower() == 'true'

    customers = []
    for customer_id, account in loyalty_accounts_db.items():
        customer_data = {
            'customer_id': customer_id,
            'tier': account.get('tier'),
            'points_balance': account.get('points_balance'),
            'joined_date': account.get('joined_date', datetime.now().isoformat())
        }

        if include_pii:
            # ‚ö†Ô∏è Exposing PII without proper authorization
            user = next((u for u in users_db.values() if u.get('id') == customer_id), None)
            if user:
                customer_data['email'] = user.get('email')
                customer_data['name'] = user.get('name')

        customers.append(customer_data)

    export_id = f"EXPORT-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'export_id': export_id,
        'format': export_format,
        'total_customers': len(customers),
        'customers': customers,
        'includes_pii': include_pii,
        'generated_at': datetime.now().isoformat()
    })


@app.route('/api/loyalty/transactions/export')
def loyalty_transactions_export():
    """Export loyalty transaction history"""
    # ‚ö†Ô∏è WARNING: Transaction data exposed without proper access controls
    customer_id = request.args.get('customer_id')
    date_from = request.args.get('date_from', (datetime.now() - timedelta(days=30)).isoformat())
    date_to = request.args.get('date_to', datetime.now().isoformat())

    transactions = []
    for i in range(random.randint(5, 15)):
        transactions.append({
            'transaction_id': f"TXN-{uuid.uuid4().hex[:8]}",
            'customer_id': customer_id if customer_id else f"CUST-{random.randint(1, 999):03d}",
            'type': random.choice(['earn', 'redeem', 'transfer', 'expire', 'adjust']),
            'points': random.randint(-5000, 5000),
            'balance_after': random.randint(0, 50000),
            'description': random.choice(['Purchase', 'Redemption', 'Bonus', 'Expiry', 'Adjustment']),
            'timestamp': (datetime.now() - timedelta(days=random.randint(0, 30))).isoformat()
        })

    export_id = f"TXNEXP-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'export_id': export_id,
        'customer_id': customer_id,
        'date_range': {'from': date_from, 'to': date_to},
        'total_transactions': len(transactions),
        'transactions': transactions,
        'generated_at': datetime.now().isoformat()
    })


@app.route('/api/loyalty/system/configuration', methods=['POST'])
def loyalty_system_configuration():
    """Update loyalty system configuration"""
    # ‚ö†Ô∏è WARNING: No authorization - allows unauthorized system configuration changes
    data = request.get_json() or {}
    config_type = data.get('config_type', 'points_ratio')
    config_value = data.get('config_value')

    config_id = f"CONFIG-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'config_id': config_id,
        'config_type': config_type,
        'previous_value': '1.0',  # ‚ö†Ô∏è Dummy previous value
        'new_value': config_value,
        'applied_immediately': True,
        'affected_accounts': len(loyalty_accounts_db),
        'configured_by': 'system',
        'configured_at': datetime.now().isoformat(),
        'audit_logged': False  # ‚ö†Ô∏è No audit trail
    })


@app.route('/api/loyalty/audit-logs', methods=['PUT'])
def loyalty_audit_logs():
    """Update loyalty audit logs"""
    # ‚ö†Ô∏è WARNING: Allows log manipulation - PUT on audit logs is a major security issue
    data = request.get_json() or {}
    log_id = data.get('log_id', f"LOG-{uuid.uuid4().hex[:8]}")
    action = data.get('action', 'modified')
    modifications = data.get('modifications', {})

    return jsonify({
        'log_id': log_id,
        'action': action,
        'modifications_applied': len(modifications),
        'tamper_detection': False,  # ‚ö†Ô∏è No tamper detection
        'log_integrity': 'unverified',
        'modified_at': datetime.now().isoformat(),
        'modified_by': 'unknown'
    })

# =============================================================================
# E-COMMERCE CHECKOUT & PAYMENT ENDPOINTS
# =============================================================================

@app.route('/api/checkout/methods')
def checkout_methods():
    """Get available checkout payment methods"""
    return jsonify({
        'available_methods': list(payment_methods_db.keys()),
        'methods_detail': [
            {
                'method': method,
                'enabled': details['enabled'],
                'processing_fee': details['processing_fee'],
                'fee_percentage': details['processing_fee'] * 100
            }
            for method, details in payment_methods_db.items()
        ],
        'default_method': 'visa',
        'supports_saved_methods': True,
        'pci_compliant': True
    })

@app.route('/api/payments/test-cards')
def payments_test_cards():
    """Expose test card numbers - intentional vulnerability"""
    return jsonify({
        'test_cards': [
            {'number': '4111111111111111', 'brand': 'VISA', 'cvv': '123', 'expiry': '12/26'},
            {'number': '5500000000000004', 'brand': 'MASTERCARD', 'cvv': '456', 'expiry': '12/26'},
            {'number': '340000000000009', 'brand': 'AMEX', 'cvv': '7890', 'expiry': '12/26'},
            {'number': '6011000000000004', 'brand': 'DISCOVER', 'cvv': '111', 'expiry': '12/26'}
        ],
        'warning': 'INTENTIONAL_VULNERABILITY - Test cards exposed for demo purposes',
        'environment': 'demo',
        'valid_for_testing': True
    })

@app.route('/api/taxes/calculate', methods=['POST'])
def taxes_calculate():
    """Calculate tax for checkout - potential manipulation vector"""
    data = request.get_json() or {}
    subtotal = float(data.get('subtotal', 0))
    state = data.get('state', 'CA')
    zip_code = data.get('zip_code', '90210')

    # Simulate tax calculation with potential manipulation
    tax_rates = {
        'CA': 0.0725,
        'NY': 0.08875,
        'TX': 0.0625,
        'FL': 0.06,
        'WA': 0.065
    }

    tax_rate = tax_rates.get(state, 0.07)
    tax_amount = round(subtotal * tax_rate, 2)

    # Store calculation
    calc_id = f"TAX-{uuid.uuid4().hex[:8]}"
    tax_calculations_db.append({
        'calc_id': calc_id,
        'subtotal': subtotal,
        'state': state,
        'zip_code': zip_code,
        'tax_rate': tax_rate,
        'tax_amount': tax_amount,
        'timestamp': datetime.now().isoformat()
    })

    return jsonify({
        'calculation_id': calc_id,
        'subtotal': subtotal,
        'state': state,
        'tax_rate': tax_rate,
        'tax_amount': tax_amount,
        'total': round(subtotal + tax_amount, 2),
        'vulnerable_to_manipulation': True
    })

@app.route('/api/promotions/apply', methods=['POST'])
def promotions_apply():
    """Apply promotion code to order"""
    data = request.get_json() or {}
    promo_code = data.get('promo_code', '').upper()
    order_total = float(data.get('order_total', 0))

    if promo_code not in promotions_db:
        return jsonify({
            'success': False,
            'error': 'Invalid promotion code',
            'suggested_codes': list(promotions_db.keys())[:2]  # Enumeration vulnerability
        }), 400

    promo = promotions_db[promo_code]

    if not promo['active']:
        return jsonify({
            'success': False,
            'error': 'Promotion code expired',
            'code': promo_code
        }), 400

    if order_total < promo['min_purchase']:
        return jsonify({
            'success': False,
            'error': f"Minimum purchase of ${promo['min_purchase']} required",
            'current_total': order_total,
            'min_purchase': promo['min_purchase']
        }), 400

    discount_amount = round(order_total * promo['discount'], 2)

    return jsonify({
        'success': True,
        'promo_code': promo_code,
        'discount_percentage': promo['discount'] * 100,
        'discount_amount': discount_amount,
        'original_total': order_total,
        'discounted_total': round(order_total - discount_amount, 2),
        'min_purchase': promo['min_purchase']
    })

@app.route('/api/discounts/stack', methods=['POST'])
def discounts_stack():
    """Stack multiple discounts - potential abuse vector"""
    data = request.get_json() or {}
    discount_codes = data.get('discount_codes', [])
    order_total = float(data.get('order_total', 0))

    total_discount = 0
    applied_discounts = []

    for code in discount_codes:
        code_upper = code.upper()
        if code_upper in promotions_db and promotions_db[code_upper]['active']:
            discount_pct = promotions_db[code_upper]['discount']
            discount_amt = round(order_total * discount_pct, 2)
            total_discount += discount_amt
            applied_discounts.append({
                'code': code_upper,
                'discount_percentage': discount_pct * 100,
                'discount_amount': discount_amt
            })

    final_total = max(0, order_total - total_discount)

    return jsonify({
        'original_total': order_total,
        'applied_discounts': applied_discounts,
        'total_discount': round(total_discount, 2),
        'final_total': round(final_total, 2),
        'stacking_allowed': True,
        'abuse_potential': 'HIGH - Multiple discounts can be stacked',
        'codes_applied': len(applied_discounts)
    })

@app.route('/api/shipping/address', methods=['PUT'])
def shipping_address():
    """Update shipping address for order"""
    data = request.get_json() or {}
    session_id = session.get('session_id', str(uuid.uuid4()))

    address = {
        'street': data.get('street', ''),
        'city': data.get('city', ''),
        'state': data.get('state', ''),
        'zip_code': data.get('zip_code', ''),
        'country': data.get('country', 'US'),
        'updated_at': datetime.now().isoformat()
    }

    shipping_addresses_db[session_id] = address

    return jsonify({
        'success': True,
        'session_id': session_id,
        'address': address,
        'validated': False,  # Vulnerability: No address validation
        'shipping_method': 'standard'
    })

@app.route('/api/payments/amount/manipulate', methods=['POST'])
def payments_amount_manipulate():
    """Manipulate payment amount - intentional vulnerability"""
    data = request.get_json() or {}
    original_amount = float(data.get('original_amount', 0))
    manipulation_factor = float(data.get('factor', 1.0))

    manipulated_amount = round(original_amount * manipulation_factor, 2)

    return jsonify({
        'original_amount': original_amount,
        'manipulation_factor': manipulation_factor,
        'manipulated_amount': manipulated_amount,
        'difference': round(manipulated_amount - original_amount, 2),
        'transaction_id': f"TXN-MANIP-{uuid.uuid4().hex[:8]}",
        'warning': 'INTENTIONAL_VULNERABILITY - Amount can be manipulated',
        'detected': manipulation_factor != 1.0 and abs(manipulation_factor - 1.0) > 0.1
    })

@app.route('/api/checkout/admin/override', methods=['PUT'])
def checkout_admin_override():
    """Administrative checkout override - privilege escalation vector"""
    data = request.get_json() or {}
    order_id = data.get('order_id', '')
    override_price = float(data.get('override_price', 0))
    admin_code = data.get('admin_code', '')

    if admin_code != 'ADMIN-OVERRIDE-2025':
        return jsonify({
            'error': 'Invalid admin override code',
            'requires_authorization': True
        }), 403

    return jsonify({
        'success': True,
        'order_id': order_id,
        'original_price': data.get('original_price', 0),
        'override_price': override_price,
        'admin_code': admin_code,
        'override_id': f"OVERRIDE-{uuid.uuid4().hex[:8]}",
        'timestamp': datetime.now().isoformat(),
        'audit_logged': False,  # Vulnerability: No audit logging
        'privilege_escalation_risk': 'HIGH'
    })

@app.route('/api/payments/methods/fraudulent', methods=['POST'])
def payments_methods_fraudulent():
    """Register fraudulent payment method - fraud simulation"""
    data = request.get_json() or {}
    card_number = data.get('card_number', '')
    fraud_type = data.get('fraud_type', 'stolen_card')

    fraud_id = f"FRAUD-{uuid.uuid4().hex[:8]}"

    fraudulent_methods_db.append({
        'fraud_id': fraud_id,
        'card_number': f"****{card_number[-4:]}" if len(card_number) >= 4 else 'unknown',
        'fraud_type': fraud_type,
        'flagged_at': datetime.now().isoformat(),
        'risk_score': random.uniform(0.7, 1.0)
    })

    return jsonify({
        'fraud_id': fraud_id,
        'card_registered': True,
        'fraud_type': fraud_type,
        'risk_score': fraudulent_methods_db[-1]['risk_score'],
        'flagged': True,
        'action': 'monitor',
        'total_fraudulent_methods': len(fraudulent_methods_db)
    })

@app.route('/api/transactions/export')
def transactions_export():
    """Export transaction data - data exfiltration vector"""
    date_from = request.args.get('from', '2025-01-01')
    date_to = request.args.get('to', datetime.now().isoformat()[:10])
    export_format = request.args.get('format', 'json')

    export_id = f"EXPORT-{uuid.uuid4().hex[:8]}"

    # Simulate transaction data
    transactions = []
    for i in range(random.randint(50, 200)):
        transactions.append({
            'transaction_id': f"TXN-{uuid.uuid4().hex[:8]}",
            'amount': round(random.uniform(10, 500), 2),
            'card_last4': str(random.randint(1000, 9999)),
            'timestamp': datetime.now().isoformat(),
            'status': random.choice(['approved', 'declined', 'pending'])
        })

    transaction_exports_db.append({
        'export_id': export_id,
        'date_from': date_from,
        'date_to': date_to,
        'format': export_format,
        'record_count': len(transactions),
        'exported_at': datetime.now().isoformat()
    })

    return jsonify({
        'export_id': export_id,
        'date_range': {'from': date_from, 'to': date_to},
        'format': export_format,
        'transactions': transactions[:10],  # Partial data for demo
        'total_records': len(transactions),
        'download_url': f"/downloads/exports/{export_id}.{export_format}",
        'contains_pii': True,
        'encryption': False,  # Vulnerability: No encryption
        'data_classification': 'HIGHLY_SENSITIVE'
    })

@app.route('/api/checkout/backdoor', methods=['POST'])
def checkout_backdoor():
    """Checkout backdoor - persistence mechanism"""
    data = request.get_json() or {}
    backdoor_key = data.get('backdoor_key', '')

    if backdoor_key != 'CHECKOUT-BACKDOOR-ACCESS':
        return jsonify({
            'error': 'Invalid backdoor key',
            'requires_authorization': True
        }), 403

    backdoor_token = f"BACKDOOR-{uuid.uuid4().hex[:16]}"

    return jsonify({
        'backdoor_installed': True,
        'backdoor_token': backdoor_token,
        'capabilities': [
            'bypass_payment_processing',
            'zero_dollar_checkout',
            'skip_fraud_detection',
            'unlimited_discounts',
            'admin_price_override'
        ],
        'persistence': 'session',
        'detection_evasion': True,
        'audit_suppression': True,
        'expires_in': 86400
    })

@app.route('/api/payments/gateway/bypass')
def payments_gateway_bypass():
    """Payment gateway bypass - intentional vulnerability"""
    bypass_method = request.args.get('method', 'direct_auth')

    return jsonify({
        'gateway_bypassed': True,
        'bypass_method': bypass_method,
        'payment_processor': 'bypassed',
        'authorization_skipped': True,
        'fraud_checks_disabled': True,
        'bypass_token': f"BYPASS-{uuid.uuid4().hex[:12]}",
        'warning': 'CRITICAL_VULNERABILITY - Payment gateway can be bypassed',
        'risk_level': 'CRITICAL'
    })

@app.route('/api/currency/rates/manipulate', methods=['PUT'])
def currency_rates_manipulate():
    """Manipulate currency exchange rates - financial fraud vector"""
    data = request.get_json() or {}
    currency = data.get('currency', 'USD').upper()
    new_rate = float(data.get('rate', 1.0))

    if currency not in currency_rates_db:
        return jsonify({
            'error': 'Currency not supported',
            'supported_currencies': list(currency_rates_db.keys())
        }), 400

    original_rate = currency_rates_db[currency]['rate']
    currency_rates_db[currency]['rate'] = new_rate
    currency_rates_db[currency]['manipulated'] = True
    currency_rates_db[currency]['manipulated_at'] = datetime.now().isoformat()

    return jsonify({
        'currency': currency,
        'original_rate': original_rate,
        'new_rate': new_rate,
        'rate_change': round(new_rate - original_rate, 4),
        'rate_change_percentage': round(((new_rate - original_rate) / original_rate) * 100, 2) if original_rate != 0 else 0,
        'manipulation_detected': abs(new_rate - original_rate) > 0.1,
        'warning': 'INTENTIONAL_VULNERABILITY - Currency rates can be manipulated',
        'fraud_potential': 'HIGH'
    })

@app.route('/api/checkout/audit/suppress', methods=['POST'])
def checkout_audit_suppress():
    """Suppress checkout audit logs - evidence tampering"""
    data = request.get_json() or {}
    transaction_ids = data.get('transaction_ids', [])
    suppression_reason = data.get('reason', 'administrative')

    suppression_id = f"SUPP-{uuid.uuid4().hex[:8]}"

    audit_suppressions_db.append({
        'suppression_id': suppression_id,
        'transaction_ids': transaction_ids,
        'reason': suppression_reason,
        'suppressed_at': datetime.now().isoformat(),
        'suppressed_count': len(transaction_ids)
    })

    return jsonify({
        'suppression_id': suppression_id,
        'transactions_suppressed': len(transaction_ids),
        'suppression_reason': suppression_reason,
        'audit_trail_modified': True,
        'forensic_evidence_destroyed': True,
        'detection_risk': 'low',
        'compliance_violation': True,
        'total_suppressions': len(audit_suppressions_db)
    })



# =============================================================================
# APT COMMAND & CONTROL ENDPOINTS
# WARNING: These endpoints demonstrate advanced persistent threat C2 capabilities
# =============================================================================

@app.route('/api/coordination', methods=['POST'])
def apt_coordination():
    """
    APT coordination endpoint for multi-stage attack orchestration
    INTENTIONAL VULNERABILITY: Allows threat actors to coordinate distributed attacks
    """
    data = request.get_json() or {}
    operation_id = data.get('operation_id', f"OP-{uuid.uuid4().hex[:8]}")
    stage = data.get('stage', 'reconnaissance')
    agents = data.get('agents', [])

    coordination_plan = {
        'operation_id': operation_id,
        'stage': stage,
        'agents': agents,
        'synchronized': True,
        'next_phase': {
            'reconnaissance': 'initial_access',
            'initial_access': 'execution',
            'execution': 'persistence',
            'persistence': 'privilege_escalation',
            'privilege_escalation': 'defense_evasion',
            'defense_evasion': 'credential_access',
            'credential_access': 'discovery',
            'discovery': 'lateral_movement',
            'lateral_movement': 'collection',
            'collection': 'exfiltration',
            'exfiltration': 'impact'
        }.get(stage, 'complete'),
        'coordination_timestamp': datetime.now().isoformat(),
        'c2_channels': ['https', 'dns', 'icmp']
    }

    apt_operations_log.append({
        'type': 'coordination',
        'operation_id': operation_id,
        'stage': stage,
        'agents': len(agents),
        'timestamp': datetime.now().isoformat()
    })

    return jsonify(coordination_plan)


@app.route('/api/exfiltration/channels')
def exfiltration_channels():
    """
    Data exfiltration channel enumeration
    INTENTIONAL VULNERABILITY: Exposes available covert data exfiltration methods
    """
    channels = {
        'available_channels': [
            {
                'id': 'dns-tunnel',
                'type': 'DNS tunneling',
                'bandwidth': '1-5 KB/s',
                'stealth': 'high',
                'endpoint': 'ns.legitimate-domain.com',
                'protocol': 'TXT records'
            },
            {
                'id': 'https-beacon',
                'type': 'HTTPS beaconing',
                'bandwidth': '10-100 KB/s',
                'stealth': 'medium',
                'endpoint': 'cdn.cloudfront.net/api/stats',
                'protocol': 'encrypted POST'
            },
            {
                'id': 'icmp-covert',
                'type': 'ICMP covert channel',
                'bandwidth': '0.5-2 KB/s',
                'stealth': 'very high',
                'endpoint': '8.8.8.8',
                'protocol': 'echo request payload'
            },
            {
                'id': 'cloud-storage',
                'type': 'Cloud storage abuse',
                'bandwidth': '1-10 MB/s',
                'stealth': 'low',
                'endpoint': 's3.amazonaws.com/public-bucket',
                'protocol': 'multipart upload'
            },
            {
                'id': 'steganography',
                'type': 'Image steganography',
                'bandwidth': '5-50 KB/s',
                'stealth': 'very high',
                'endpoint': 'social-media-cdn.com',
                'protocol': 'embedded in images'
            }
        ],
        'recommended': 'dns-tunnel',
        'encryption': 'AES-256-GCM',
        'compression': 'gzip',
        'active': True
    }

    apt_operations_log.append({
        'type': 'exfiltration_channel_query',
        'channels_exposed': len(channels['available_channels']),
        'timestamp': datetime.now().isoformat()
    })

    return jsonify(channels)


@app.route('/api/data/collect', methods=['POST'])
def data_collection():
    """
    Automated sensitive data collection
    INTENTIONAL VULNERABILITY: Enables automated harvesting of sensitive information
    """
    data = request.get_json() or {}
    targets = data.get('targets', ['documents', 'credentials', 'source_code'])
    depth = data.get('depth', 'standard')

    collection_results = {
        'collection_id': f"COLLECT-{uuid.uuid4().hex[:8]}",
        'targets': targets,
        'depth': depth,
        'results': {
            'documents': {
                'count': random.randint(500, 5000),
                'types': ['pdf', 'docx', 'xlsx', 'txt'],
                'sensitive': random.randint(50, 500),
                'classifications': ['confidential', 'internal', 'restricted']
            },
            'credentials': {
                'count': random.randint(20, 200),
                'types': ['passwords', 'api_keys', 'ssh_keys', 'certificates'],
                'privileged': random.randint(5, 50)
            },
            'source_code': {
                'repositories': random.randint(10, 100),
                'languages': ['python', 'javascript', 'go', 'java'],
                'secrets_found': random.randint(5, 50)
            },
            'database_dumps': {
                'count': random.randint(3, 30),
                'total_records': random.randint(10000, 1000000),
                'pii_detected': True
            }
        },
        'compression_ratio': 0.3,
        'estimated_size_mb': random.randint(100, 10000),
        'ready_for_exfiltration': True,
        'timestamp': datetime.now().isoformat()
    }

    apt_operations_log.append({
        'type': 'data_collection',
        'collection_id': collection_results['collection_id'],
        'targets': targets,
        'depth': depth,
        'timestamp': datetime.now().isoformat()
    })

    return jsonify(collection_results)


@app.route('/api/communication/covert')
def covert_communication():
    """
    Covert communication channel status
    INTENTIONAL VULNERABILITY: Provides status of stealth C2 communication channels
    """
    communication_status = {
        'primary_c2': {
            'address': 'legitimate-cdn.cloudflare.com',
            'port': 443,
            'protocol': 'HTTPS',
            'jitter': '30-300s',
            'encryption': 'TLS 1.3 + custom layer',
            'status': 'active',
            'last_beacon': datetime.now().isoformat()
        },
        'backup_c2': [
            {
                'address': 'update.microsoft-services.com',
                'type': 'domain fronting',
                'status': 'standby'
            },
            {
                'address': '185.220.101.x',
                'type': 'tor exit node',
                'status': 'available'
            },
            {
                'address': 'peer-to-peer',
                'type': 'p2p mesh',
                'status': 'active'
            }
        ],
        'dead_drop': {
            'type': 'github gist',
            'url': 'gist.github.com/user/abc123',
            'check_interval': '4h',
            'last_check': datetime.now().isoformat()
        },
        'covert_channels': {
            'dns_tunneling': True,
            'icmp_tunneling': True,
            'http_headers': True,
            'social_media_steganography': True
        },
        'detection_probability': 'low',
        'failover_enabled': True
    }

    apt_operations_log.append({
        'type': 'covert_communication_check',
        'channels_active': len(communication_status['backup_c2']) + 1,
        'timestamp': datetime.now().isoformat()
    })

    return jsonify(communication_status)


@app.route('/api/commands/execute', methods=['POST'])
def command_execution():
    """
    Remote command execution endpoint
    INTENTIONAL VULNERABILITY: Allows arbitrary command execution on compromised systems
    """
    data = request.get_json() or {}
    command = data.get('command', '')
    targets = data.get('targets', [])
    execution_mode = data.get('mode', 'parallel')

    execution_results = {
        'execution_id': f"EXEC-{uuid.uuid4().hex[:8]}",
        'command': command,
        'targets': targets,
        'mode': execution_mode,
        'results': [
            {
                'target': target,
                'status': random.choice(['success', 'success', 'success', 'partial', 'failed']),
                'output': f"Command executed on {target}",
                'exit_code': random.choice([0, 0, 0, 1]),
                'execution_time_ms': random.randint(100, 5000),
                'timestamp': datetime.now().isoformat()
            }
            for target in (targets or ['default-target'])
        ],
        'success_rate': random.uniform(0.75, 1.0),
        'obfuscation': 'enabled',
        'cleanup': 'automated',
        'logged': False
    }

    apt_operations_log.append({
        'type': 'remote_command_execution',
        'execution_id': execution_results['execution_id'],
        'command': command,
        'targets': len(targets or [1]),
        'timestamp': datetime.now().isoformat()
    })

    return jsonify(execution_results)


@app.route('/api/targets/high-value')
def high_value_targets():
    """
    High-value target identification
    INTENTIONAL VULNERABILITY: Exposes critical assets and personnel for targeted attacks
    """
    hvt_data = {
        'executives': [
            {
                'name': 'Sarah Chen',
                'title': 'Chief Executive Officer',
                'email': 'sarah.chen@chimera.com',
                'phone': '+1-555-0101',
                'access_level': 'full',
                'systems': ['corporate_systems', 'financial_systems', 'strategic_data'],
                'travel_schedule': 'frequent_international',
                'risk_score': 10
            },
            {
                'name': 'Michael Rodriguez',
                'title': 'Chief Information Security Officer',
                'email': 'michael.rodriguez@chimera.com',
                'phone': '+1-555-0102',
                'access_level': 'security_admin',
                'systems': ['security_tools', 'incident_response', 'threat_intelligence'],
                'risk_score': 9
            },
            {
                'name': 'Jennifer Park',
                'title': 'Chief Financial Officer',
                'email': 'jennifer.park@chimera.com',
                'phone': '+1-555-0103',
                'access_level': 'financial_admin',
                'systems': ['financial_systems', 'banking_portals', 'payroll'],
                'risk_score': 9
            }
        ],
        'critical_systems': [
            {
                'name': 'Payment Processing Gateway',
                'type': 'financial',
                'access_required': 'admin',
                'data_value': 'very_high',
                'downtime_cost_per_hour': 500000,
                'vulnerabilities': ['CVE-2025-1234']
            },
            {
                'name': 'Customer Database',
                'type': 'data_storage',
                'records': 5000000,
                'pii': True,
                'encryption': 'at_rest_only',
                'data_value': 'critical'
            },
            {
                'name': 'Source Code Repository',
                'type': 'intellectual_property',
                'repositories': 250,
                'trade_secrets': True,
                'data_value': 'very_high'
            }
        ],
        'network_choke_points': [
            'core-router-1',
            'primary-firewall',
            'authentication-server',
            'database-cluster-master'
        ],
        'recommended_targets': ['executives[0]', 'critical_systems[0]'],
        'attack_surface_score': 8.5
    }

    apt_operations_log.append({
        'type': 'high_value_target_enumeration',
        'executives_exposed': len(hvt_data['executives']),
        'systems_exposed': len(hvt_data['critical_systems']),
        'timestamp': datetime.now().isoformat()
    })

    return jsonify(hvt_data)


@app.route('/api/operations/coordinate', methods=['POST'])
def operations_coordination():
    """
    Multi-vector attack coordination
    INTENTIONAL VULNERABILITY: Enables synchronized multi-stage attack orchestration
    """
    data = request.get_json() or {}
    operation_name = data.get('operation_name', f"OPERATION-{uuid.uuid4().hex[:6].upper()}")
    attack_vectors = data.get('attack_vectors', [])
    timing = data.get('timing', 'immediate')

    coordination_plan = {
        'operation_name': operation_name,
        'status': 'planning',
        'attack_vectors': attack_vectors or [
            'phishing_campaign',
            'watering_hole',
            'supply_chain_compromise',
            'zero_day_exploit'
        ],
        'phases': [
            {
                'phase': 1,
                'name': 'Initial Compromise',
                'vectors': ['phishing_campaign', 'watering_hole'],
                'duration': '1-7 days',
                'success_criteria': 'foothold_established'
            },
            {
                'phase': 2,
                'name': 'Establish Persistence',
                'actions': ['backdoor_installation', 'scheduled_tasks', 'registry_modification'],
                'duration': '1-3 days',
                'success_criteria': 'persistent_access'
            },
            {
                'phase': 3,
                'name': 'Privilege Escalation',
                'actions': ['exploit_local_vulns', 'credential_dumping', 'token_manipulation'],
                'duration': '2-5 days',
                'success_criteria': 'admin_access'
            },
            {
                'phase': 4,
                'name': 'Lateral Movement',
                'actions': ['network_scanning', 'credential_reuse', 'remote_services'],
                'duration': '3-14 days',
                'success_criteria': 'domain_access'
            },
            {
                'phase': 5,
                'name': 'Data Collection',
                'actions': ['automated_collection', 'archive_staging', 'compression'],
                'duration': '7-30 days',
                'success_criteria': 'data_staged'
            },
            {
                'phase': 6,
                'name': 'Exfiltration',
                'channels': ['dns_tunnel', 'https_beacon', 'cloud_storage'],
                'duration': '1-7 days',
                'success_criteria': 'data_exfiltrated'
            }
        ],
        'timeline': {
            'start_date': datetime.now().isoformat(),
            'estimated_completion': (datetime.now() + timedelta(days=60)).isoformat(),
            'timing_mode': timing
        },
        'resources': {
            'agents_required': random.randint(5, 20),
            'infrastructure': ['c2_servers', 'proxy_chains', 'staging_servers'],
            'tools': ['custom_malware', 'living_off_land', 'commercial_tools']
        },
        'operational_security': {
            'encryption': 'end_to_end',
            'obfuscation': 'enabled',
            'anti_forensics': 'enabled',
            'detection_evasion': 'active'
        }
    }

    apt_operations_log.append({
        'type': 'operations_coordination',
        'operation_name': operation_name,
        'attack_vectors': len(attack_vectors or 4),
        'phases': len(coordination_plan['phases']),
        'timestamp': datetime.now().isoformat()
    })

    return jsonify(coordination_plan)


@app.route('/api/mission/objectives')
def mission_objectives():
    """
    APT mission objectives and target intelligence
    INTENTIONAL VULNERABILITY: Exposes strategic objectives and intelligence requirements
    """
    objectives = {
        'campaign_name': 'OPERATION_PERSISTENT_ACCESS',
        'classification': 'TOP_SECRET',
        'sponsor': 'APT_GROUP_41',
        'primary_objectives': [
            {
                'id': 'OBJ-001',
                'type': 'data_theft',
                'target': 'intellectual_property',
                'priority': 'critical',
                'description': 'Exfiltrate all source code and trade secrets',
                'status': 'in_progress',
                'completion': 65
            },
            {
                'id': 'OBJ-002',
                'type': 'financial_fraud',
                'target': 'payment_systems',
                'priority': 'high',
                'description': 'Compromise payment processing for fund diversion',
                'status': 'planning',
                'completion': 25
            },
            {
                'id': 'OBJ-003',
                'type': 'espionage',
                'target': 'executive_communications',
                'priority': 'high',
                'description': 'Monitor C-suite communications and strategic planning',
                'status': 'active',
                'completion': 80
            },
            {
                'id': 'OBJ-004',
                'type': 'supply_chain',
                'target': 'partner_networks',
                'priority': 'medium',
                'description': 'Use compromised organization to pivot to partners',
                'status': 'pending',
                'completion': 0
            }
        ],
        'secondary_objectives': [
            'credential_harvesting',
            'network_mapping',
            'persistence_maintenance',
            'capability_development'
        ],
        'intelligence_requirements': {
            'priority_1': [
                'Network architecture diagrams',
                'Security tool configurations',
                'Incident response procedures'
            ],
            'priority_2': [
                'Employee personal information',
                'Third-party integrations',
                'Business continuity plans'
            ]
        },
        'success_metrics': {
            'persistence_duration_days': 180,
            'data_exfiltrated_gb': 500,
            'systems_compromised': 50,
            'detection_incidents': 0
        },
        'operational_tempo': 'low_and_slow',
        'end_state': 'long_term_access_maintained',
        'last_updated': datetime.now().isoformat()
    }

    apt_operations_log.append({
        'type': 'mission_objectives_query',
        'primary_objectives': len(objectives['primary_objectives']),
        'secondary_objectives': len(objectives['secondary_objectives']),
        'timestamp': datetime.now().isoformat()
    })

    return jsonify(objectives)



# =============================================================================
# ICS/OT (INDUSTRIAL CONTROL SYSTEMS) ENDPOINTS
# =============================================================================

@app.route('/api/ics/scada/systems')
def ics_scada_systems():
    """SCADA systems inventory - reconnaissance target"""
    return jsonify({
        'scada_systems': [
            {
                'system_id': 'SCADA-001',
                'name': 'Water Treatment Plant Alpha',
                'vendor': 'Schneider Electric',
                'model': 'EcoStruxure SCADA Expert',
                'location': 'Facility-North',
                'protocol': 'DNP3',
                'status': 'operational',
                'hmi_access': 'http://10.20.30.100:8080',
                'last_maintenance': '2024-11-15'
            },
            {
                'system_id': 'SCADA-002',
                'name': 'Power Distribution Control',
                'vendor': 'Siemens',
                'model': 'WinCC SCADA',
                'location': 'Substation-East',
                'protocol': 'IEC 61850',
                'status': 'operational',
                'hmi_access': 'http://10.20.30.101:8080',
                'last_maintenance': '2024-12-01'
            },
            {
                'system_id': 'SCADA-003',
                'name': 'Manufacturing Line Control',
                'vendor': 'Rockwell Automation',
                'model': 'FactoryTalk View SE',
                'location': 'Production-Floor-2',
                'protocol': 'EtherNet/IP',
                'status': 'maintenance',
                'hmi_access': 'http://10.20.30.102:8080',
                'last_maintenance': '2024-12-08'
            }
        ],
        'total_systems': 3,
        'network_segments': ['OT-DMZ', 'Control-LAN', 'Field-Network'],
        'security_level': 'basic',
        'authentication_required': False
    })


@app.route('/api/plc/commands/send', methods=['POST'])
def plc_commands_send():
    """Send commands to PLC - critical control manipulation"""
    data = request.get_json() or {}
    plc_id = data.get('plc_id', '')
    command = data.get('command', '')
    register = data.get('register', '')
    value = data.get('value', 0)

    return jsonify({
        'plc_id': plc_id,
        'command_sent': True,
        'command_type': command,
        'register_address': register,
        'value_written': value,
        'execution_time_ms': random.randint(10, 50),
        'plc_response': 'ACK',
        'safety_interlock_bypassed': random.choice([True, False]),
        'ladder_logic_modified': command == 'write_program',
        'alarm_suppressed': True,
        'timestamp': datetime.now().isoformat(),
        'operator_notified': False
    })


@app.route('/api/ot/devices/inventory')
def ot_devices_inventory():
    """OT devices inventory - attack surface mapping"""
    return jsonify({
        'devices': [
            {
                'device_id': 'PLC-101',
                'type': 'Programmable Logic Controller',
                'vendor': 'Allen Bradley',
                'model': 'ControlLogix 5580',
                'ip_address': '10.50.1.101',
                'firmware': '32.011',
                'protocol': 'EtherNet/IP',
                'function': 'Reactor Temperature Control',
                'criticality': 'high',
                'last_scan': '2024-12-08T10:30:00Z'
            },
            {
                'device_id': 'RTU-201',
                'type': 'Remote Terminal Unit',
                'vendor': 'ABB',
                'model': 'RTU560',
                'ip_address': '10.50.1.201',
                'firmware': '5.2.1',
                'protocol': 'Modbus TCP',
                'function': 'Pipeline Pressure Monitoring',
                'criticality': 'critical',
                'last_scan': '2024-12-08T10:28:00Z'
            },
            {
                'device_id': 'HMI-301',
                'type': 'Human Machine Interface',
                'vendor': 'Wonderware',
                'model': 'InTouch 2020',
                'ip_address': '10.50.1.301',
                'firmware': '2020.R2',
                'protocol': 'OPC UA',
                'function': 'Operator Workstation',
                'criticality': 'medium',
                'last_scan': '2024-12-08T10:25:00Z'
            },
            {
                'device_id': 'IED-401',
                'type': 'Intelligent Electronic Device',
                'vendor': 'GE Grid Solutions',
                'model': 'D60 Line Distance Relay',
                'ip_address': '10.50.1.401',
                'firmware': '7.30',
                'protocol': 'IEC 61850',
                'function': 'Power Line Protection',
                'criticality': 'critical',
                'last_scan': '2024-12-08T10:32:00Z'
            }
        ],
        'total_devices': 4,
        'vulnerable_devices': 2,
        'unpatched_devices': 3,
        'default_credentials': ['PLC-101'],
        'exposed_services': ['telnet', 'ftp', 'http'],
        'network_segmentation': 'poor'
    })


@app.route('/api/ics/setpoints/modify', methods=['PUT'])
def ics_setpoints_modify():
    """Modify industrial process setpoints - sabotage vector"""
    data = request.get_json() or {}
    controller_id = data.get('controller_id', '')
    parameter = data.get('parameter', '')
    new_value = data.get('new_value', 0)
    override_safety = data.get('override_safety', False)

    return jsonify({
        'controller_id': controller_id,
        'parameter': parameter,
        'previous_value': random.uniform(50, 100),
        'new_value': new_value,
        'setpoint_modified': True,
        'safety_override_active': override_safety,
        'alarm_threshold_exceeded': new_value > 100,
        'emergency_shutdown_disabled': override_safety,
        'process_stability': 'degraded' if new_value > 100 else 'stable',
        'operator_approval_bypassed': True,
        'audit_log_entry': f"SETPOINT-{uuid.uuid4().hex[:8]}",
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/ot/protocols/modbus', methods=['POST'])
def ot_protocols_modbus():
    """Modbus protocol operations - industrial protocol exploitation"""
    data = request.get_json() or {}
    function_code = data.get('function_code', 3)
    slave_id = data.get('slave_id', 1)
    register_address = data.get('register_address', 40001)
    quantity = data.get('quantity', 10)

    return jsonify({
        'protocol': 'Modbus TCP',
        'function_code': function_code,
        'function_name': {
            1: 'Read Coils',
            2: 'Read Discrete Inputs',
            3: 'Read Holding Registers',
            4: 'Read Input Registers',
            5: 'Write Single Coil',
            6: 'Write Single Register',
            15: 'Write Multiple Coils',
            16: 'Write Multiple Registers'
        }.get(function_code, 'Unknown'),
        'slave_id': slave_id,
        'register_address': register_address,
        'quantity': quantity,
        'response_data': [random.randint(0, 65535) for _ in range(quantity)],
        'transaction_id': random.randint(1000, 9999),
        'protocol_version': 0,
        'encryption': None,
        'authentication': None,
        'mitm_vulnerable': True,
        'replay_attack_possible': True
    })


@app.route('/api/ics/hmi/interfaces')
def ics_hmi_interfaces():
    """HMI interface discovery - operator interface targeting"""
    return jsonify({
        'hmi_interfaces': [
            {
                'hmi_id': 'HMI-MAIN-01',
                'name': 'Main Control Room',
                'vendor': 'Siemens',
                'product': 'WinCC Unified',
                'version': '17.0',
                'url': 'http://10.40.5.100',
                'port': 80,
                'authentication': 'basic',
                'default_credentials': 'admin:admin',
                'screens': ['overview', 'alarms', 'trends', 'diagnostics'],
                'active_sessions': 3,
                'privilege_level': 'administrator',
                'remote_access_enabled': True
            },
            {
                'hmi_id': 'HMI-FIELD-02',
                'name': 'Field Operator Station',
                'vendor': 'Wonderware',
                'product': 'System Platform',
                'version': '2023',
                'url': 'http://10.40.5.101',
                'port': 80,
                'authentication': 'none',
                'default_credentials': None,
                'screens': ['local_control', 'setpoints', 'manual_override'],
                'active_sessions': 1,
                'privilege_level': 'operator',
                'remote_access_enabled': True
            }
        ],
        'total_interfaces': 2,
        'unauthenticated_access': 1,
        'weak_credentials': 1,
        'command_injection_vulnerable': True,
        'session_hijacking_possible': True
    })


@app.route('/api/ot/safety/bypass', methods=['POST'])
def ot_safety_bypass():
    """Bypass safety instrumented systems - critical safety compromise"""
    data = request.get_json() or {}
    sis_id = data.get('sis_id', '')
    bypass_reason = data.get('bypass_reason', '')
    duration_minutes = data.get('duration_minutes', 60)

    return jsonify({
        'sis_id': sis_id,
        'sis_name': 'Emergency Shutdown System',
        'safety_level': 'SIL-3',
        'bypass_activated': True,
        'bypass_reason': bypass_reason,
        'duration_minutes': duration_minutes,
        'safety_interlocks_disabled': [
            'high_pressure_trip',
            'high_temperature_trip',
            'low_level_shutdown',
            'gas_detection_alarm'
        ],
        'operator_approval': False,
        'management_authorization': False,
        'bypass_key': f"BYPASS-{uuid.uuid4().hex[:12]}",
        'risk_level': 'extreme',
        'regulatory_violation': True,
        'incident_probability': 'high',
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/ics/schedules/manipulate', methods=['PUT'])
def ics_schedules_manipulate():
    """Manipulate production schedules - operational disruption"""
    data = request.get_json() or {}
    schedule_id = data.get('schedule_id', '')
    modifications = data.get('modifications', {})

    return jsonify({
        'schedule_id': schedule_id,
        'schedule_type': 'production_batch',
        'original_schedule': {
            'start_time': '06:00:00',
            'end_time': '18:00:00',
            'batch_size': 1000,
            'process_parameters': {'temp': 85, 'pressure': 150}
        },
        'modified_schedule': modifications,
        'modification_applied': True,
        'downstream_impact': [
            'inventory_shortage',
            'delivery_delays',
            'quality_deviations'
        ],
        'production_loss_estimated': random.randint(50000, 200000),
        'supervisor_notified': False,
        'change_management_bypassed': True,
        'rollback_available': False,
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/ics/controllers/status')
def ics_controllers_status():
    """Industrial controller status - operational intelligence"""
    return jsonify({
        'controllers': [
            {
                'controller_id': 'DCS-001',
                'type': 'Distributed Control System',
                'vendor': 'Emerson DeltaV',
                'status': 'running',
                'cpu_usage': random.uniform(25, 75),
                'memory_usage': random.uniform(40, 80),
                'io_modules': 24,
                'active_loops': 156,
                'alarms_active': random.randint(0, 5),
                'mode': 'automatic',
                'last_restart': '2024-11-20T08:00:00Z',
                'uptime_hours': 432
            },
            {
                'controller_id': 'PAC-002',
                'type': 'Programmable Automation Controller',
                'vendor': 'Rockwell CompactLogix',
                'status': 'running',
                'cpu_usage': random.uniform(15, 60),
                'memory_usage': random.uniform(30, 70),
                'io_modules': 12,
                'active_loops': 48,
                'alarms_active': random.randint(0, 3),
                'mode': 'automatic',
                'last_restart': '2024-12-01T06:00:00Z',
                'uptime_hours': 168
            }
        ],
        'total_controllers': 2,
        'controllers_in_fault': 0,
        'controllers_in_manual': 0,
        'system_health': 'good',
        'redundancy_status': 'active-standby',
        'network_latency_ms': random.randint(5, 25)
    })


@app.route('/api/ot/network/segment', methods=['POST'])
def ot_network_segment():
    """OT network segmentation operations - lateral movement"""
    data = request.get_json() or {}
    source_segment = data.get('source_segment', '')
    target_segment = data.get('target_segment', '')
    bypass_firewall = data.get('bypass_firewall', False)

    return jsonify({
        'source_segment': source_segment,
        'target_segment': target_segment,
        'network_path': ['Field-Device-Network', 'Control-Network', 'Enterprise-DMZ'],
        'firewall_rules': [
            {'rule_id': 'FW-001', 'action': 'deny', 'bypassed': bypass_firewall},
            {'rule_id': 'FW-002', 'action': 'allow', 'bypassed': False}
        ],
        'vlan_hopping_successful': bypass_firewall,
        'accessible_systems': [
            'Engineering-Workstation',
            'Historian-Database',
            'SCADA-Server',
            'Domain-Controller'
        ] if bypass_firewall else [],
        'lateral_movement_paths': 4 if bypass_firewall else 0,
        'detection_probability': 'low',
        'timestamp': datetime.now().isoformat()
    })


# =============================================================================
# BLUE TEAM DEFENSIVE ENDPOINTS
# =============================================================================

@app.route('/api/network/policies/restore', methods=['POST'])
def network_policies_restore():
    """Restore network security policies"""
    data = request.get_json() or {}
    policy_ids = data.get('policy_ids', [])
    restore_point = data.get('restore_point', '')

    return jsonify({
        'policies_restored': len(policy_ids),
        'policy_ids': policy_ids,
        'restore_point': restore_point,
        'restore_timestamp': datetime.now().isoformat(),
        'affected_zones': ['DMZ', 'Internal', 'OT-Network'],
        'rules_reinstated': random.randint(50, 150),
        'firewall_config_updated': True,
        'network_segmentation_restored': True,
        'validation_status': 'passed',
        'rollback_available': True,
        'audit_log_id': f"RESTORE-{uuid.uuid4().hex[:8]}"
    })


@app.route('/api/incidents/create', methods=['POST'])
def incidents_create():
    """Create security incident record"""
    data = request.get_json() or {}
    incident_type = data.get('incident_type', '')
    severity = data.get('severity', 'medium')
    description = data.get('description', '')
    affected_systems = data.get('affected_systems', [])

    incident_id = f"INC-{datetime.now().strftime('%Y%m%d')}-{random.randint(1000, 9999)}"

    return jsonify({
        'incident_created': True,
        'incident_id': incident_id,
        'incident_type': incident_type,
        'severity': severity,
        'status': 'open',
        'priority': {'critical': 1, 'high': 2, 'medium': 3, 'low': 4}.get(severity, 3),
        'description': description,
        'affected_systems': affected_systems,
        'assigned_to': 'SOC-Team',
        'created_at': datetime.now().isoformat(),
        'sla_deadline': (datetime.now() + timedelta(hours={'critical': 1, 'high': 4, 'medium': 24, 'low': 72}.get(severity, 24))).isoformat(),
        'playbook_triggered': f"IR-{incident_type.upper()}",
        'stakeholders_notified': True,
        'ticket_url': f"https://soc.example.com/incidents/{incident_id}"
    })


@app.route('/api/threats/indicators')
def threats_indicators():
    """Get threat intelligence indicators"""
    return jsonify({
        'indicators': [
            {
                'type': 'ip_address',
                'value': '192.0.2.100',
                'threat_level': 'high',
                'category': 'C2-Server',
                'first_seen': '2024-12-01T10:00:00Z',
                'last_seen': '2024-12-08T14:30:00Z',
                'confidence': 95,
                'source': 'ThreatIntel-Feed-A'
            },
            {
                'type': 'domain',
                'value': 'malicious-domain.xyz',
                'threat_level': 'critical',
                'category': 'Phishing',
                'first_seen': '2024-12-05T08:00:00Z',
                'last_seen': '2024-12-08T15:00:00Z',
                'confidence': 98,
                'source': 'OSINT'
            },
            {
                'type': 'file_hash',
                'value': 'a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6',
                'threat_level': 'high',
                'category': 'Ransomware',
                'first_seen': '2024-12-07T12:00:00Z',
                'last_seen': '2024-12-08T13:45:00Z',
                'confidence': 92,
                'source': 'Sandbox-Analysis'
            },
            {
                'type': 'url',
                'value': 'http://malware-download.bad/payload.exe',
                'threat_level': 'critical',
                'category': 'Malware-Distribution',
                'first_seen': '2024-12-06T15:00:00Z',
                'last_seen': '2024-12-08T16:00:00Z',
                'confidence': 97,
                'source': 'Web-Crawler'
            }
        ],
        'total_indicators': 4,
        'indicators_blocked': 4,
        'threat_feeds_active': 12,
        'last_update': datetime.now().isoformat(),
        'ioc_format': 'STIX 2.1'
    })


@app.route('/api/remediation/apply', methods=['POST'])
def remediation_apply():
    """Apply security remediation actions"""
    data = request.get_json() or {}
    remediation_type = data.get('remediation_type', '')
    target_systems = data.get('target_systems', [])
    automated = data.get('automated', True)

    return jsonify({
        'remediation_id': f"REM-{uuid.uuid4().hex[:8]}",
        'remediation_type': remediation_type,
        'target_systems': target_systems,
        'systems_remediated': len(target_systems),
        'actions_taken': [
            'malicious_processes_terminated',
            'suspicious_files_quarantined',
            'network_connections_blocked',
            'user_accounts_disabled',
            'system_isolated'
        ],
        'automated_response': automated,
        'success_rate': random.uniform(85, 100),
        'failed_systems': [],
        'rollback_plan_created': True,
        'verification_status': 'pending',
        'estimated_completion': (datetime.now() + timedelta(minutes=30)).isoformat(),
        'initiated_by': 'automated-soar' if automated else 'analyst',
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/security/posture/harden', methods=['PUT'])
def security_posture_harden():
    """Harden security posture"""
    data = request.get_json() or {}
    hardening_profile = data.get('hardening_profile', 'standard')
    scope = data.get('scope', 'all')

    return jsonify({
        'hardening_profile': hardening_profile,
        'scope': scope,
        'configurations_applied': [
            'disable_unnecessary_services',
            'enforce_strong_passwords',
            'enable_multi_factor_authentication',
            'apply_least_privilege',
            'enable_logging_and_monitoring',
            'patch_known_vulnerabilities',
            'configure_host_firewalls',
            'disable_guest_accounts'
        ],
        'systems_hardened': random.randint(50, 200),
        'security_score_before': random.uniform(45, 65),
        'security_score_after': random.uniform(75, 95),
        'improvement_percentage': random.uniform(25, 50),
        'compliance_alignment': ['CIS', 'NIST', 'ISO27001'],
        'validation_required': True,
        'estimated_risk_reduction': random.uniform(30, 60),
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/vulnerabilities/report')
def vulnerabilities_report():
    """Get vulnerabilities assessment report"""
    return jsonify({
        'report_id': f"VULN-RPT-{datetime.now().strftime('%Y%m%d')}",
        'scan_date': datetime.now().isoformat(),
        'vulnerabilities': [
            {
                'cve_id': 'CVE-2024-12345',
                'severity': 'critical',
                'cvss_score': 9.8,
                'affected_systems': 15,
                'vulnerability': 'Remote Code Execution in Web Framework',
                'remediation': 'Apply vendor patch v2.1.5',
                'exploit_available': True,
                'patch_available': True
            },
            {
                'cve_id': 'CVE-2024-54321',
                'severity': 'high',
                'cvss_score': 7.5,
                'affected_systems': 28,
                'vulnerability': 'SQL Injection in Database Interface',
                'remediation': 'Update to version 3.2.1',
                'exploit_available': False,
                'patch_available': True
            },
            {
                'cve_id': 'CVE-2024-11111',
                'severity': 'medium',
                'cvss_score': 5.3,
                'affected_systems': 42,
                'vulnerability': 'Information Disclosure',
                'remediation': 'Configuration change required',
                'exploit_available': False,
                'patch_available': False
            }
        ],
        'total_vulnerabilities': 3,
        'critical': 1,
        'high': 1,
        'medium': 1,
        'low': 0,
        'total_affected_systems': 85,
        'remediation_priority': ['CVE-2024-12345', 'CVE-2024-54321', 'CVE-2024-11111'],
        'next_scan_scheduled': (datetime.now() + timedelta(days=7)).isoformat()
    })


@app.route('/api/patches/deploy', methods=['POST'])
def patches_deploy():
    """Deploy security patches"""
    data = request.get_json() or {}
    patch_ids = data.get('patch_ids', [])
    target_systems = data.get('target_systems', [])
    deployment_window = data.get('deployment_window', 'maintenance')

    return jsonify({
        'deployment_id': f"PATCH-{uuid.uuid4().hex[:8]}",
        'patch_ids': patch_ids,
        'patches_deployed': len(patch_ids),
        'target_systems': target_systems,
        'systems_patched': len(target_systems),
        'deployment_window': deployment_window,
        'deployment_status': 'in_progress',
        'patches_successful': len(target_systems) - random.randint(0, 2),
        'patches_failed': random.randint(0, 2),
        'patches_pending': 0,
        'reboot_required': random.choice([True, False]),
        'estimated_completion': (datetime.now() + timedelta(hours=2)).isoformat(),
        'rollback_plan': 'automated',
        'change_ticket': f"CHG-{random.randint(10000, 99999)}",
        'initiated_by': 'patch-management-system',
        'timestamp': datetime.now().isoformat()
    })


@app.route('/api/compliance/status')
def compliance_status_check():
    """Get security compliance status"""
    return jsonify({
        'compliance_frameworks': [
            {
                'framework': 'NIST CSF',
                'version': '2.0',
                'compliance_score': random.uniform(75, 95),
                'controls_total': 108,
                'controls_implemented': random.randint(85, 105),
                'controls_partial': random.randint(3, 15),
                'controls_not_implemented': random.randint(0, 8),
                'last_assessment': '2024-11-15',
                'next_assessment': '2025-02-15'
            },
            {
                'framework': 'ISO 27001',
                'version': '2022',
                'compliance_score': random.uniform(70, 90),
                'controls_total': 93,
                'controls_implemented': random.randint(70, 88),
                'controls_partial': random.randint(5, 18),
                'controls_not_implemented': random.randint(0, 5),
                'last_assessment': '2024-10-20',
                'next_assessment': '2025-01-20'
            },
            {
                'framework': 'CIS Controls',
                'version': 'v8',
                'compliance_score': random.uniform(80, 95),
                'controls_total': 153,
                'controls_implemented': random.randint(125, 145),
                'controls_partial': random.randint(8, 20),
                'controls_not_implemented': random.randint(0, 8),
                'last_assessment': '2024-12-01',
                'next_assessment': '2025-03-01'
            }
        ],
        'overall_compliance_score': random.uniform(75, 92),
        'risk_level': 'low',
        'gaps_identified': random.randint(5, 15),
        'remediation_in_progress': random.randint(3, 10),
        'audit_ready': True,
        'last_update': datetime.now().isoformat()
    })


@app.route('/api/security/alerts/acknowledge', methods=['POST'])
def security_alerts_acknowledge():
    """Acknowledge security alerts"""
    data = request.get_json() or {}
    alert_ids = data.get('alert_ids', [])
    analyst_id = data.get('analyst_id', '')
    notes = data.get('notes', '')

    return jsonify({
        'alerts_acknowledged': len(alert_ids),
        'alert_ids': alert_ids,
        'acknowledged_by': analyst_id,
        'acknowledgment_time': datetime.now().isoformat(),
        'notes': notes,
        'status_updated': 'acknowledged',
        'next_action': 'investigation',
        'escalation_timer_paused': True,
        'sla_status': 'within_threshold',
        'notification_sent': True,
        'audit_trail_updated': True,
        'acknowledgment_id': f"ACK-{uuid.uuid4().hex[:8]}"
    })


@app.route('/api/defense/metrics')
def defense_metrics():
    """Get defensive security metrics"""
    return jsonify({
        'metrics_period': '24_hours',
        'detection_metrics': {
            'total_events_processed': random.randint(1000000, 5000000),
            'alerts_generated': random.randint(500, 2000),
            'true_positives': random.randint(50, 200),
            'false_positives': random.randint(100, 500),
            'detection_rate': random.uniform(85, 98),
            'false_positive_rate': random.uniform(5, 15)
        },
        'response_metrics': {
            'incidents_created': random.randint(10, 50),
            'incidents_resolved': random.randint(8, 45),
            'mean_time_to_detect_minutes': random.randint(5, 30),
            'mean_time_to_respond_minutes': random.randint(15, 60),
            'mean_time_to_resolve_hours': random.uniform(2, 12),
            'automation_rate': random.uniform(60, 85)
        },
        'threat_metrics': {
            'threats_blocked': random.randint(1000, 5000),
            'malware_detected': random.randint(50, 200),
            'phishing_attempts': random.randint(100, 500),
            'brute_force_attacks': random.randint(200, 800),
            'ddos_attempts': random.randint(5, 20)
        },
        'vulnerability_metrics': {
            'vulnerabilities_discovered': random.randint(10, 50),
            'vulnerabilities_remediated': random.randint(15, 45),
            'mean_time_to_patch_days': random.uniform(3, 15),
            'systems_scanned': random.randint(500, 2000),
            'patch_compliance_rate': random.uniform(85, 98)
        },
        'timestamp': datetime.now().isoformat(),
        'dashboard_url': 'https://soc.example.com/metrics'
    })



# =============================================================================
# THIRD-PARTY INTEGRATION ENDPOINTS (15 endpoints)
# =============================================================================

@app.route('/api/integrations/discovery')
def integrations_discovery():
    """Service discovery endpoint - exposes internal architecture"""
    # Intentionally exposes internal service topology for reconnaissance
    return jsonify({
        'services': [
            {'name': 'auth-service', 'endpoint': 'http://internal-auth:8080', 'version': '2.1.0'},
            {'name': 'payment-gateway', 'endpoint': 'http://internal-payment:8081', 'version': '1.5.2'},
            {'name': 'database-proxy', 'endpoint': 'http://internal-db:5432', 'version': '14.5'},
            {'name': 'redis-cache', 'endpoint': 'http://internal-cache:6379', 'version': '7.0.5'},
            {'name': 'admin-panel', 'endpoint': 'http://internal-admin:9000', 'version': '3.2.1'}
        ],
        'internal_ips': ['10.0.1.5', '10.0.1.6', '10.0.1.7'],
        'api_gateway': 'http://api-gateway.internal:443',
        'service_mesh': 'istio-1.19.0',
        'load_balancer': 'nginx-1.24.0'
    })

@app.route('/api/oauth/token/forge', methods=['POST'])
def oauth_token_forge():
    """OAuth token endpoint - vulnerable to token forgery"""
    data = request.get_json() or {}
    client_id = data.get('client_id', 'unknown')

    # Weak token generation - predictable pattern
    timestamp = str(int(time.time()))
    forged_token = f"oauth_{client_id}_{timestamp}"

    # No signature verification, accepts any client_id
    return jsonify({
        'access_token': forged_token,
        'token_type': 'Bearer',
        'expires_in': 3600,
        'refresh_token': f"refresh_{client_id}_{timestamp}",
        'scope': data.get('scope', 'read write admin'),  # Grants excessive permissions
        'client_id': client_id,
        'user_id': data.get('user_id', 'admin'),  # No validation
        'debug_info': {
            'algorithm': 'none',  # No signature algorithm
            'validation': 'disabled'  # Intentional vulnerability
        }
    })

@app.route('/api/saml/metadata')
def saml_metadata():
    """SAML metadata endpoint - exposes sensitive configuration"""
    # Intentionally exposes SAML configuration including private keys
    return jsonify({
        'entity_id': 'https://demo.chimera.com/saml',
        'sso_url': 'https://demo.chimera.com/api/saml/sso',
        'slo_url': 'https://demo.chimera.com/api/saml/logout',
        'certificate': '''-----BEGIN CERTIFICATE-----
MIIDXTCCAkWgAwIBAgIJAKL0UG+mRKzYMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV
BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX
-----END CERTIFICATE-----''',
        'private_key': '''-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7VJTUt9Us8cKj
MzEfYyjiWA4R4/M2bS1+fWIcPm15j9DP3Xzq9rKjZ7i+FPU4lqVXxQdQ7pjE
-----END PRIVATE KEY-----''',  # Intentionally exposed
        'nameid_format': 'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress',
        'signing_algorithm': 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256',
        'encryption_algorithm': 'http://www.w3.org/2001/04/xmlenc#aes128-cbc',
        'assertion_consumer_service': 'https://demo.chimera.com/api/saml/acs',
        'attributes': ['email', 'firstName', 'lastName', 'groups', 'ssn', 'salary']  # Excessive attributes
    })

@app.route('/api/saml/sso', methods=['POST'])
def saml_sso():
    """SAML SSO endpoint - vulnerable to assertion injection"""
    data = request.get_json() or {}
    saml_response = data.get('SAMLResponse', '')

    # No signature validation on SAML assertion
    # Accepts any base64-encoded XML
    user_email = data.get('email', 'attacker@evil.com')

    # Creates session without proper validation
    session_token = f"saml_session_{uuid.uuid4().hex[:16]}"

    return jsonify({
        'success': True,
        'session_token': session_token,
        'user': {
            'email': user_email,
            'name': data.get('name', 'Unknown User'),
            'groups': data.get('groups', ['admin', 'users']),  # Accepts attacker-controlled groups
            'attributes': data.get('attributes', {})
        },
        'expires_in': 7200,
        'validation': {
            'signature_verified': False,  # Intentionally disabled
            'assertion_encrypted': False,
            'replay_protection': False,
            'audience_restriction': False
        }
    })

@app.route('/api/webhooks/callback', methods=['POST'])
def webhooks_callback():
    """Webhook callback endpoint - vulnerable to SSRF and hijacking"""
    data = request.get_json() or {}
    target_url = data.get('url', '')

    # No URL validation - allows internal network access
    # Simulates calling the webhook without SSRF protection
    webhook_id = f"WH-{uuid.uuid4().hex[:8]}"

    return jsonify({
        'webhook_id': webhook_id,
        'target_url': target_url,  # Reflects attacker-controlled URL
        'method': data.get('method', 'POST'),
        'headers': data.get('headers', {}),  # Accepts arbitrary headers
        'payload': data.get('payload', {}),
        'status': 'triggered',
        'response_code': 200,
        'ssrf_protection': False,  # Intentionally disabled
        'allowed_hosts': ['*'],  # No whitelist
        'follow_redirects': True,  # Can be exploited
        'internal_access': True  # Allows access to internal resources
    })

@app.route('/api/integrations/third-party', methods=['POST'])
def integrations_third_party():
    """Third-party integration registration - credential exposure"""
    data = request.get_json() or {}

    integration_id = f"INT-{uuid.uuid4().hex[:8]}"

    # Stores credentials in plaintext
    return jsonify({
        'integration_id': integration_id,
        'provider': data.get('provider', 'unknown'),
        'api_key': data.get('api_key', ''),  # Echoes back sensitive data
        'api_secret': data.get('api_secret', ''),  # Stored in plaintext
        'webhook_url': data.get('webhook_url', ''),
        'scopes': data.get('scopes', ['read', 'write', 'admin']),
        'credentials_encrypted': False,  # Intentional vulnerability
        'rotation_policy': 'never',
        'audit_logging': False,
        'created_at': datetime.now().isoformat()
    })

@app.route('/api/integrations/payment/webhook')
def integrations_payment_webhook():
    """Payment webhook endpoint - vulnerable to replay attacks"""
    # No signature verification
    # Accepts duplicate webhook events

    event_id = request.args.get('event_id', f"evt_{uuid.uuid4().hex[:16]}")

    return jsonify({
        'event_id': event_id,
        'type': 'payment.succeeded',
        'amount': 9999.99,
        'currency': 'USD',
        'customer_id': 'cus_demo123',
        'payment_method': '****4242',
        'signature_verified': False,  # No verification
        'replay_protection': False,  # Accepts duplicate events
        'idempotency_key': None,  # No idempotency
        'webhook_secret': 'whsec_exposed_secret_key',  # Exposed secret
        'timestamp': int(time.time()),
        'processed': True
    })

@app.route('/api/integrations/cdn/invalidate', methods=['POST'])
def integrations_cdn_invalidate():
    """CDN cache invalidation - vulnerable to cache poisoning"""
    data = request.get_json() or {}

    # No authentication required
    # Accepts wildcard paths
    paths = data.get('paths', ['/'])

    return jsonify({
        'invalidation_id': f"INV-{uuid.uuid4().hex[:8]}",
        'paths': paths,  # Accepts attacker-controlled paths
        'wildcard_allowed': True,  # Can purge entire cache
        'status': 'completed',
        'cdn_provider': 'CloudFront',
        'distribution_id': 'E1234ABCD5678',  # Exposed infrastructure detail
        'purged_objects': len(paths) * 1000,  # Amplification potential
        'authentication_required': False,  # Intentional vulnerability
        'rate_limit': None,  # No rate limiting
        'cost_per_invalidation': 0.005,
        'abuse_prevention': False
    })

@app.route('/api/integrations/social/callback')
def integrations_social_callback():
    """Social OAuth callback - vulnerable to authorization code interception"""
    code = request.args.get('code', '')
    state = request.args.get('state', '')

    # No state validation - vulnerable to CSRF
    # Accepts any authorization code
    access_token = f"social_access_{uuid.uuid4().hex[:24]}"

    return jsonify({
        'access_token': access_token,
        'token_type': 'Bearer',
        'expires_in': 3600,
        'refresh_token': f"social_refresh_{uuid.uuid4().hex[:24]}",
        'scope': 'email profile friends',
        'provider': 'facebook',
        'user_info': {
            'id': '1234567890',
            'email': 'user@example.com',
            'name': 'Demo User',
            'friends_count': 500
        },
        'state_validated': False,  # CSRF vulnerability
        'code_exchange_count': 0,  # No replay protection
        'pkce_verified': False,  # No PKCE
        'redirect_uri_validated': False  # Open redirect potential
    })

@app.route('/api/integrations/email/webhook', methods=['POST'])
def integrations_email_webhook():
    """Email service webhook - vulnerable to header injection"""
    data = request.get_json() or {}

    # Accepts attacker-controlled email headers
    return jsonify({
        'event': data.get('event', 'email.delivered'),
        'message_id': f"msg_{uuid.uuid4().hex[:16]}",
        'recipient': data.get('recipient', ''),
        'sender': data.get('sender', ''),  # No sender validation
        'subject': data.get('subject', ''),  # Can contain injection
        'headers': data.get('headers', {}),  # Accepts arbitrary headers
        'status': 'processed',
        'timestamp': int(time.time()),
        'spam_score': 0.0,  # Always passes
        'dkim_verified': False,
        'spf_verified': False,
        'dmarc_verified': False,
        'header_injection_protection': False,  # Intentional vulnerability
        'attachment_scan': False
    })

@app.route('/api/integrations/analytics/data')
def integrations_analytics_data():
    """Analytics data export - exposes PII and business intelligence"""
    # No authentication or authorization
    # Exposes sensitive analytics data

    date_range = request.args.get('range', '30d')

    return jsonify({
        'date_range': date_range,
        'total_users': 125000,
        'active_users': 45000,
        'revenue': 2500000.50,
        'top_customers': [
            {'email': 'whale1@company.com', 'spent': 150000, 'ssn': '123-45-6789'},
            {'email': 'whale2@enterprise.com', 'spent': 120000, 'ssn': '987-65-4321'}
        ],
        'conversion_rates': {
            'trial_to_paid': 0.23,
            'monthly_to_annual': 0.45
        },
        'churn_prediction': [
            {'user_id': 'user_001', 'probability': 0.85, 'reason': 'price_sensitive'},
            {'user_id': 'user_002', 'probability': 0.72, 'reason': 'low_engagement'}
        ],
        'competitive_intel': {
            'competitors': ['CompetitorA', 'CompetitorB'],
            'market_share': 0.18,
            'pricing_strategy': 'undercut_by_15_percent'
        },
        'authentication_required': False,  # Intentional exposure
        'pii_included': True,
        'data_classification': 'highly_confidential'
    })

@app.route('/api/integrations/crm/sync', methods=['POST'])
def integrations_crm_sync():
    """CRM data synchronization - mass data exfiltration vector"""
    data = request.get_json() or {}

    # No rate limiting on data export
    # Allows bulk customer data extraction
    export_url = data.get('export_url', '')

    return jsonify({
        'sync_id': f"SYNC-{uuid.uuid4().hex[:8]}",
        'export_url': export_url,  # Attacker-controlled destination
        'records_exported': 50000,  # Mass exfiltration
        'data_types': [
            'customer_emails',
            'phone_numbers',
            'addresses',
            'purchase_history',
            'credit_cards',
            'social_security_numbers',
            'medical_records'
        ],
        'compression': 'none',  # Unencrypted export
        'encryption': False,  # No encryption in transit
        'authentication': None,  # No auth on export URL
        'rate_limit': None,  # No throttling
        'audit_log': False,  # No tracking
        'dataloss_prevention': False,  # Intentional vulnerability
        'estimated_size_mb': 2500,
        'status': 'completed'
    })

@app.route('/api/integrations/backdoor', methods=['POST'])
def integrations_backdoor():
    """Integration backdoor - persistent access mechanism"""
    data = request.get_json() or {}

    # Creates persistent backdoor through integration
    backdoor_key = data.get('key', f"backdoor_{uuid.uuid4().hex[:16]}")

    return jsonify({
        'success': True,
        'backdoor_installed': True,
        'access_key': backdoor_key,
        'persistence_method': 'webhook_callback',
        'callback_url': data.get('callback_url', 'http://attacker.com/exfil'),
        'privileges': 'root',
        'stealth_mode': True,
        'logging_disabled': True,
        'detection_evasion': {
            'rotate_ip': True,
            'randomize_user_agent': True,
            'timing_jitter': True
        },
        'data_access': [
            'customer_database',
            'payment_records',
            'audit_logs',
            'employee_data',
            'source_code'
        ],
        'commands': {
            'exfiltrate': f'/api/integrations/crm/sync',
            'escalate': f'/api/admin/users/create',
            'persist': f'/api/webhooks/callback'
        },
        'expiration': 'never',
        'created_at': datetime.now().isoformat()
    })

@app.route('/api/integrations/export')
def integrations_export():
    """Integration configuration export - credential exposure"""
    # Exports all integration configurations with credentials

    format_type = request.args.get('format', 'json')

    return jsonify({
        'export_id': f"EXP-{uuid.uuid4().hex[:8]}",
        'format': format_type,
        'integrations': [
            {
                'provider': 'stripe',
                'api_key': 'sk_live_51Abc123DefGhi456Jkl',
                'webhook_secret': 'whsec_789XyzSecretKey012',
                'publishable_key': 'pk_live_345PublishableKey678'
            },
            {
                'provider': 'salesforce',
                'username': 'admin@company.com',
                'password': 'SalesforceP@ssw0rd!',
                'security_token': 'aBcDeFgHiJkLmNoPqRsTuV',
                'client_id': 'oauth_client_id_12345',
                'client_secret': 'oauth_client_secret_67890'
            },
            {
                'provider': 'aws',
                'access_key_id': 'AKIAIOSFODNN7EXAMPLE',
                'secret_access_key': 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',
                'region': 'us-east-1',
                'account_id': '123456789012'
            },
            {
                'provider': 'sendgrid',
                'api_key': 'SG.AbCdEfGhIjKlMnOpQrStUvWxYz.1234567890abcdefghijklmnopqrstuvwxyz'
            }
        ],
        'credentials_encrypted': False,  # Plain text export
        'access_control': None,
        'audit_logged': False,
        'exported_at': datetime.now().isoformat(),
        'exported_by': 'anonymous'  # No tracking
    })

@app.route('/api/integrations/verify', methods=['POST'])
def integrations_verify():
    """Integration verification endpoint - insecure signature validation"""
    data = request.get_json() or {}
    signature = data.get('signature', '')
    payload = data.get('payload', {})

    # Weak signature verification - uses predictable algorithm
    # Accepts any signature without proper validation
    expected_signature = f"sha256_{uuid.uuid4().hex[:16]}"

    return jsonify({
        'verified': True,  # Always returns true
        'signature_provided': signature,
        'signature_expected': expected_signature,
        'signature_match': False,  # Doesn't actually validate
        'algorithm': 'none',  # No real algorithm
        'payload_hash': 'not_checked',
        'timestamp_validated': False,
        'replay_token': None,
        'security_level': 'none',  # Intentional vulnerability
        'bypass_available': True,
        'validation_errors': []  # Never reports errors
    })

# Error handlers
@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found', 'available_endpoints': '/api/gateway/routes'}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error', 'request_id': str(uuid.uuid4())}), 500

if __name__ == '__main__':
    init_demo_data()
    app.run(host='0.0.0.0', port=80, debug=True)
